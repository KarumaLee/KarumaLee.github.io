<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>置顶 | 总之是一个置顶</title>
    <url>/2022/04/20/topList/</url>
    <content><![CDATA[<p>还没有想好置顶什么</p>
<span id="more"></span>
<p>总之就是还没有想好置顶什么</p>
]]></content>
  </entry>
  <entry>
    <title>GAN - 生成对抗网络的基础代码实现</title>
    <url>/2024/09/28/GAN-%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>最近沉迷于GAN，整理了一下基础部分的代码。</p>
<span id="more"></span>
<h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><p> GAN(Generative adversarial network)，即生成对抗网络。网络中有两个模型，分别是生成器(Generator)和判别器(Discriminator)。生成器负责生成所需数据，优化的思路是让他骗过判别器的判断；判别器负责对数据进行判断，优化的思路是让他的判断更准确。</p>
<h4 id="库文件及工具函数"><a href="#库文件及工具函数" class="headerlink" title="库文件及工具函数"></a>库文件及工具函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> make_grid</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 用于显示图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从Tensor显示图像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_tensor_images</span>(<span class="params">image_tensor, num_images=<span class="number">25</span>, size=(<span class="params"><span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span></span>)</span>):</span><br><span class="line">	image_unflat = image_tensor.detach().cpu().view(-<span class="number">1</span>, *size)</span><br><span class="line">	image_grid = make_grid(image_unflat[:num_images], nrow=<span class="number">5</span>)</span><br><span class="line">	plt.imshow(image_grid.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).squeeze())</span><br><span class="line">	plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 生成一个随机噪音</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_noise</span>(<span class="params">n_samples, z_dim, device=<span class="string">&#x27;cpu&#x27;</span></span>):</span><br><span class="line">	<span class="keyword">return</span> torch.randn(n_samples, z_dim, device=device)</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span>(nn.Module):</span><br><span class="line">    <span class="comment"># 生成器传入噪声(随机数)，输出所需图片</span></span><br><span class="line">    <span class="comment"># 这里使用最简单的模型结构，即三层线性层</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, z_dim=<span class="number">10</span>, im_dim=<span class="number">784</span>, hidden_dim=<span class="number">128</span></span>):</span><br><span class="line">		<span class="built_in">super</span>(Generator, self).__init__()</span><br><span class="line">		self.gen = nn.Sequential(</span><br><span class="line">			get_generator_block(z_dim, hidden_dim),</span><br><span class="line">			get_generator_block(hidden_dim, hidden_dim * <span class="number">2</span>),</span><br><span class="line">			get_generator_block(hidden_dim * <span class="number">2</span>, hidden_dim * <span class="number">4</span>),</span><br><span class="line">			get_generator_block(hidden_dim * <span class="number">4</span>, hidden_dim * <span class="number">8</span>),</span><br><span class="line">			nn.Linear(hidden_dim * <span class="number">8</span>, im_dim),</span><br><span class="line">			nn.Sigmoid()</span><br><span class="line">		)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, noise</span>):</span><br><span class="line">		<span class="keyword">return</span> self.gen(noise)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_gen</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.gen</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_generator_block</span>(<span class="params">input_dim, output_dim</span>):</span><br><span class="line">	<span class="keyword">return</span> nn.Sequential(</span><br><span class="line">		nn.Linear(input_dim, output_dim),</span><br><span class="line">		nn.BatchNorm1d(output_dim),</span><br><span class="line">		nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<h4 id="判别器"><a href="#判别器" class="headerlink" title="判别器"></a>判别器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Discriminator</span>(nn.Module):</span><br><span class="line">    <span class="comment"># 生成器传入数据，输出一个数字，表示是真实图片还是生成图片</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, im_dim=<span class="number">784</span>, hidden_dim=<span class="number">128</span></span>):</span><br><span class="line">		<span class="built_in">super</span>(Discriminator, self).__init__()</span><br><span class="line">		self.disc = nn.Sequential(</span><br><span class="line">			get_discriminator_block(im_dim, hidden_dim * <span class="number">4</span>),</span><br><span class="line">			get_discriminator_block(hidden_dim * <span class="number">4</span>, hidden_dim * <span class="number">2</span>),</span><br><span class="line">			get_discriminator_block(hidden_dim * <span class="number">2</span>, hidden_dim),</span><br><span class="line">			nn.Linear(hidden_dim, <span class="number">1</span>)</span><br><span class="line">		)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, image</span>):</span><br><span class="line">		<span class="keyword">return</span> self.disc(image)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_disc</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.disc</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_discriminator_block</span>(<span class="params">input_dim, output_dim</span>):</span><br><span class="line">	<span class="keyword">return</span> nn.Sequential(</span><br><span class="line">		nn.Linear(input_dim, output_dim),</span><br><span class="line">		nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<h4 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion = nn.BCEWithLogitsLoss() <span class="comment"># 交叉熵损失来使得值更靠近1或者0</span></span><br><span class="line">n_epochs = <span class="number">200</span></span><br><span class="line">z_dim = <span class="number">64</span></span><br><span class="line">display_step = <span class="number">500</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">lr = <span class="number">0.00001</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span></span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(</span><br><span class="line">	MNIST(<span class="string">&#x27;.&#x27;</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor()),</span><br><span class="line">	batch_size=batch_size,</span><br><span class="line">	shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gen = Generator(z_dim).to(device)</span><br><span class="line">gen_opt = torch.optim.Adam(gen.parameters(), lr=lr)</span><br><span class="line">disc = Discriminator().to(device)</span><br><span class="line">disc_opt = torch.optim.Adam(disc.parameters(), lr=lr)</span><br></pre></td></tr></table></figure>

<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_disc_loss</span>(<span class="params">gen, disc, criterion, real, num_images, z_dim, device</span>):</span><br><span class="line">	fake_noise = get_noise(num_images, z_dim, device=device)</span><br><span class="line">	fake = gen(fake_noise)</span><br><span class="line">	disc_fake_pred = disc(fake.detach())</span><br><span class="line">	disc_fake_loss = criterion(disc_fake_pred, torch.zeros_like(disc_fake_pred)) <span class="comment"># 让假数据的判断接近0</span></span><br><span class="line">	disc_real_pred = disc(real)</span><br><span class="line">	disc_real_loss = criterion(disc_real_pred, torch.ones_like(disc_real_pred)) <span class="comment"># 让真数据的判断接近1</span></span><br><span class="line">	disc_loss = (disc_fake_loss + disc_real_loss) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> disc_loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gen_loss</span>(<span class="params">gen, disc, criterion, num_images, z_dim, device</span>):</span><br><span class="line">	fake_noise = get_noise(num_images, z_dim, device=device)</span><br><span class="line">	fake = gen(fake_noise)</span><br><span class="line">	disc_fake_pred = disc(fake)</span><br><span class="line">	gen_loss = criterion(disc_fake_pred, torch.ones_like(disc_fake_pred)) <span class="comment"># 让假数据的判断接近1</span></span><br><span class="line">	<span class="keyword">return</span> gen_loss</span><br></pre></td></tr></table></figure>

<h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur_step = <span class="number">0</span></span><br><span class="line">mean_generator_loss = <span class="number">0</span></span><br><span class="line">mean_discriminator_loss = <span class="number">0</span></span><br><span class="line">logs = []</span><br><span class="line">msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">	<span class="keyword">for</span> real, _ <span class="keyword">in</span> tqdm(dataloader, desc=<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>&#x27;</span>):</span><br><span class="line">		cur_batch_size = <span class="built_in">len</span>(real)</span><br><span class="line">		real = real.view(cur_batch_size, -<span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练判别器</span></span><br><span class="line">		disc_opt.zero_grad()</span><br><span class="line">		disc_loss = get_disc_loss(gen, disc, criterion, real, cur_batch_size, z_dim, device)</span><br><span class="line">		disc_loss.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">		disc_opt.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练生成器</span></span><br><span class="line">		gen_opt.zero_grad()</span><br><span class="line">		gen_loss = get_gen_loss(gen, disc, criterion, cur_batch_size, z_dim, device)</span><br><span class="line">		gen_loss.backward()</span><br><span class="line">		gen_opt.step()</span><br><span class="line"></span><br><span class="line">		mean_discriminator_loss += disc_loss.item() / display_step</span><br><span class="line">		mean_generator_loss += gen_loss.item() / display_step</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录数据</span></span><br><span class="line">		<span class="keyword">if</span> cur_step % display_step == <span class="number">0</span> <span class="keyword">and</span> cur_step &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="comment"># print(f&quot;Step &#123;cur_step&#125;: Generator loss: &#123;mean_generator_loss&#125;, discriminator loss: &#123;mean_discriminator_loss&#125;&quot;)</span></span><br><span class="line">			msg = <span class="string">f&quot;Step <span class="subst">&#123;cur_step&#125;</span>: Generator loss: <span class="subst">&#123;mean_generator_loss&#125;</span>, discriminator loss: <span class="subst">&#123;mean_discriminator_loss&#125;</span>&quot;</span></span><br><span class="line">			logs.append(msg)</span><br><span class="line">			fake_noise = get_noise(cur_batch_size, z_dim, device=device)</span><br><span class="line">			fake = gen(fake_noise)</span><br><span class="line">			show_tensor_images(fake)</span><br><span class="line">			show_tensor_images(real)</span><br><span class="line">			mean_discriminator_loss = <span class="number">0</span></span><br><span class="line">			mean_generator_loss = <span class="number">0</span></span><br><span class="line">		cur_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> logs:</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> make_grid</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_tensor_images</span>(<span class="params">image_tensor, num_images=<span class="number">25</span>, size=(<span class="params"><span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span></span>)</span>):</span><br><span class="line">	image_unflat = image_tensor.detach().cpu().view(-<span class="number">1</span>, *size)</span><br><span class="line">	image_grid = make_grid(image_unflat[:num_images], nrow=<span class="number">5</span>)</span><br><span class="line">	plt.imshow(image_grid.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>).squeeze())</span><br><span class="line">	plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_generator_block</span>(<span class="params">input_dim, output_dim</span>):</span><br><span class="line">	<span class="keyword">return</span> nn.Sequential(</span><br><span class="line">		nn.Linear(input_dim, output_dim),</span><br><span class="line">		nn.BatchNorm1d(output_dim),</span><br><span class="line">		nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span>(nn.Module):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, z_dim=<span class="number">10</span>, im_dim=<span class="number">784</span>, hidden_dim=<span class="number">128</span></span>):</span><br><span class="line">		<span class="built_in">super</span>(Generator, self).__init__()</span><br><span class="line">		self.gen = nn.Sequential(</span><br><span class="line">			get_generator_block(z_dim, hidden_dim),</span><br><span class="line">			get_generator_block(hidden_dim, hidden_dim * <span class="number">2</span>),</span><br><span class="line">			get_generator_block(hidden_dim * <span class="number">2</span>, hidden_dim * <span class="number">4</span>),</span><br><span class="line">			get_generator_block(hidden_dim * <span class="number">4</span>, hidden_dim * <span class="number">8</span>),</span><br><span class="line">			nn.Linear(hidden_dim * <span class="number">8</span>, im_dim),</span><br><span class="line">			nn.Sigmoid()</span><br><span class="line">		)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, noise</span>):</span><br><span class="line">		<span class="keyword">return</span> self.gen(noise)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_gen</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.gen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_noise</span>(<span class="params">n_samples, z_dim, device=<span class="string">&#x27;cpu&#x27;</span></span>):</span><br><span class="line">	<span class="keyword">return</span> torch.randn(n_samples, z_dim, device=device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_discriminator_block</span>(<span class="params">input_dim, output_dim</span>):</span><br><span class="line">	<span class="keyword">return</span> nn.Sequential(</span><br><span class="line">		nn.Linear(input_dim, output_dim),</span><br><span class="line">		nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Discriminator</span>(nn.Module):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, im_dim=<span class="number">784</span>, hidden_dim=<span class="number">128</span></span>):</span><br><span class="line">		<span class="built_in">super</span>(Discriminator, self).__init__()</span><br><span class="line">		self.disc = nn.Sequential(</span><br><span class="line">			get_discriminator_block(im_dim, hidden_dim * <span class="number">4</span>),</span><br><span class="line">			get_discriminator_block(hidden_dim * <span class="number">4</span>, hidden_dim * <span class="number">2</span>),</span><br><span class="line">			get_discriminator_block(hidden_dim * <span class="number">2</span>, hidden_dim),</span><br><span class="line">			nn.Linear(hidden_dim, <span class="number">1</span>)</span><br><span class="line">		)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, image</span>):</span><br><span class="line">		<span class="keyword">return</span> self.disc(image)</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_disc</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.disc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">criterion = nn.BCEWithLogitsLoss()</span><br><span class="line">n_epochs = <span class="number">200</span></span><br><span class="line">z_dim = <span class="number">64</span></span><br><span class="line">display_step = <span class="number">500</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">lr = <span class="number">0.00001</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span></span><br><span class="line"></span><br><span class="line">dataloader = DataLoader(</span><br><span class="line">	MNIST(<span class="string">&#x27;.&#x27;</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor()),</span><br><span class="line">	batch_size=batch_size,</span><br><span class="line">	shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gen = Generator(z_dim).to(device)</span><br><span class="line">gen_opt = torch.optim.Adam(gen.parameters(), lr=lr)</span><br><span class="line">disc = Discriminator().to(device)</span><br><span class="line">disc_opt = torch.optim.Adam(disc.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_disc_loss</span>(<span class="params">gen, disc, criterion, real, num_images, z_dim, device</span>):</span><br><span class="line">	fake_noise = get_noise(num_images, z_dim, device=device)</span><br><span class="line">	fake = gen(fake_noise)</span><br><span class="line">	disc_fake_pred = disc(fake.detach())</span><br><span class="line">	disc_fake_loss = criterion(disc_fake_pred, torch.zeros_like(disc_fake_pred))</span><br><span class="line">	disc_real_pred = disc(real)</span><br><span class="line">	disc_real_loss = criterion(disc_real_pred, torch.ones_like(disc_real_pred))</span><br><span class="line">	disc_loss = (disc_fake_loss + disc_real_loss) / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> disc_loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_gen_loss</span>(<span class="params">gen, disc, criterion, num_images, z_dim, device</span>):</span><br><span class="line">	fake_noise = get_noise(num_images, z_dim, device=device)</span><br><span class="line">	fake = gen(fake_noise)</span><br><span class="line">	disc_fake_pred = disc(fake)</span><br><span class="line">	gen_loss = criterion(disc_fake_pred, torch.ones_like(disc_fake_pred))</span><br><span class="line">	<span class="keyword">return</span> gen_loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cur_step = <span class="number">0</span></span><br><span class="line">mean_generator_loss = <span class="number">0</span></span><br><span class="line">mean_discriminator_loss = <span class="number">0</span></span><br><span class="line">logs = []</span><br><span class="line">msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">	<span class="keyword">for</span> real, _ <span class="keyword">in</span> tqdm(dataloader, desc=<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>&#x27;</span>):</span><br><span class="line">		cur_batch_size = <span class="built_in">len</span>(real)</span><br><span class="line">		real = real.view(cur_batch_size, -<span class="number">1</span>).to(device)</span><br><span class="line"></span><br><span class="line">		disc_opt.zero_grad()</span><br><span class="line">		disc_loss = get_disc_loss(gen, disc, criterion, real, cur_batch_size, z_dim, device)</span><br><span class="line">		disc_loss.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">		disc_opt.step()</span><br><span class="line"></span><br><span class="line">		gen_opt.zero_grad()</span><br><span class="line">		gen_loss = get_gen_loss(gen, disc, criterion, cur_batch_size, z_dim, device)</span><br><span class="line">		gen_loss.backward()</span><br><span class="line">		gen_opt.step()</span><br><span class="line"></span><br><span class="line">		mean_discriminator_loss += disc_loss.item() / display_step</span><br><span class="line">		mean_generator_loss += gen_loss.item() / display_step</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> cur_step % display_step == <span class="number">0</span> <span class="keyword">and</span> cur_step &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="comment"># print(f&quot;Step &#123;cur_step&#125;: Generator loss: &#123;mean_generator_loss&#125;, discriminator loss: &#123;mean_discriminator_loss&#125;&quot;)</span></span><br><span class="line">			msg = <span class="string">f&quot;Step <span class="subst">&#123;cur_step&#125;</span>: Generator loss: <span class="subst">&#123;mean_generator_loss&#125;</span>, discriminator loss: <span class="subst">&#123;mean_discriminator_loss&#125;</span>&quot;</span></span><br><span class="line">			logs.append(msg)</span><br><span class="line">			fake_noise = get_noise(cur_batch_size, z_dim, device=device)</span><br><span class="line">			fake = gen(fake_noise)</span><br><span class="line">			show_tensor_images(fake)</span><br><span class="line">			show_tensor_images(real)</span><br><span class="line">			mean_discriminator_loss = <span class="number">0</span></span><br><span class="line">			mean_generator_loss = <span class="number">0</span></span><br><span class="line">		cur_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> logs:</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>CV计算机视觉</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第一周</title>
    <url>/2022/03/24/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第一周题解</p>
<span id="more"></span>
<h4 id="AcWing-3346-你知道你的ABC吗—原题链接"><a href="#AcWing-3346-你知道你的ABC吗—原题链接" class="headerlink" title="AcWing 3346. 你知道你的ABC吗—原题链接"></a>AcWing 3346. 你知道你的ABC吗—<a href="https://www.acwing.com/problem/content/3349/">原题链接</a></h4><p>题目标签：思维题 | 数学推理  </p>
<blockquote>
<p>思路：<br>由于7个数进行排序，第一个第二个数一定是a和b，第三个数有两种可能，要么是c，要么是a+b，如果是后者的话那么第四个数一定是c，也就是说进行一个小判断就行（某场cf的a题原题）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a+<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//判断第三个数是c还是a+b</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] + a[<span class="number">1</span>] == a[<span class="number">2</span>]) cout &lt;&lt; a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; a[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-3358-放养但没有完全放养—原题链接"><a href="#AcWing-3358-放养但没有完全放养—原题链接" class="headerlink" title="AcWing 3358. 放养但没有完全放养—原题链接"></a>AcWing 3358. 放养但没有完全放养—<a href="https://www.acwing.com/problem/content/3361/">原题链接</a></h4><p>题目标签：字符串 | 模拟 | 贪心(?)  </p>
<blockquote>
<p>思路1：<br>题目要求输出唱了多少遍，也就是一共需要听几遍才能按顺序听完目标字符串，那么：<br>Q：为什么需要再听一边<br>A：因为当前遍历到的字母之后不存在下一个字母，所以需要再听一遍<br>Q：什么时候需要再听一遍<br>A：当前字母出现的位置在之前字母的前边或者相同，因为如果在后边的话继续听下去是可以听到的<br>因此本题就是根据每个字母的位置进行比对</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">string s, s0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s0 &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(&#123;s0[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> flag = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        <span class="type">int</span> a = mp[flag], b = mp[c];</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= b) cnt++;</span><br><span class="line">        flag = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br>对上述的思路进行优化，字母顺序的比对直接遍历一遍就可以了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">26</span>];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++) p[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt;= p[s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span>]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3370-牛年—原题链接"><a href="#AcWing-3370-牛年—原题链接" class="headerlink" title="AcWing 3370. 牛年—原题链接"></a>AcWing 3370. 牛年—<a href="https://www.acwing.com/problem/content/3373/">原题链接</a></h4><p>题目标签：（自以为是的）DFS | 模拟  </p>
<blockquote>
<p>思路1：<br>建图DFS， <strong>虽然AC了但是是很绕弯子的思路</strong>拿到题的时候很自信的以为是图的深搜，结果敲了将近一个小时越来越觉得不对劲…虽说很别扭但是逻辑上可以说得通，并且很幸运的能够AC……坐等正解，看个乐子吧就当</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">1</span>, res;</span><br><span class="line"><span class="type">int</span> born[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> h[N * N], w[N * N], e[N * N], ne[N * N], idx;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp, day;</span><br><span class="line">string dayy[<span class="number">12</span>] = &#123;<span class="string">&quot;Ox&quot;</span>, <span class="string">&quot;Tiger&quot;</span>, <span class="string">&quot;Rabbit&quot;</span>, <span class="string">&quot;Dragon&quot;</span>, <span class="string">&quot;Snake&quot;</span>, <span class="string">&quot;Horse&quot;</span>, <span class="string">&quot;Goat&quot;</span>, <span class="string">&quot;Monkey&quot;</span>, <span class="string">&quot;Rooster&quot;</span>, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Pig&quot;</span>, <span class="string">&quot;Rat&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = u, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node == mp[<span class="string">&quot;Bessie&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        res = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[node]; i!=<span class="number">-1</span>; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j, sum + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        day.<span class="built_in">insert</span>(&#123;dayy[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    mp[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    born[<span class="number">0</span>] = mp[<span class="string">&quot;Ox&quot;</span>];</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++) cin &gt;&gt; str[j];</span><br><span class="line">        string name1 = str[<span class="number">0</span>], name2 = str[<span class="number">7</span>], year = str[<span class="number">4</span>], sta = str[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mp[name1] == <span class="number">0</span>) mp[name1] = cnt++;</span><br><span class="line">        <span class="keyword">if</span>(mp[name2] == <span class="number">0</span>) mp[name2] = cnt++;</span><br><span class="line"></span><br><span class="line">        born[mp[name1]] = day[year];</span><br><span class="line">        <span class="type">int</span> a = born[mp[name1]], b = born[mp[name2]], d;</span><br><span class="line">        <span class="keyword">if</span>(a == b) d = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - b + a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(mp[<span class="string">&quot;Elsie&quot;</span>], <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(res) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br><strong>因为题目中保证了后者的名字一定在前面出现过</strong>，所以其实只要简单模拟就可以了不需要做图的搜索。<br>另外关于距离部分，只需要做一次同余方程就可以减少很多代码量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; id = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Ox&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;Tiger&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Rabbit&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dragon&quot;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&quot;Snake&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;Horse&quot;</span>, <span class="number">5</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Goat&quot;</span>, <span class="number">6</span>&#125;, &#123;<span class="string">&quot;Monkey&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;Rooster&quot;</span>, <span class="number">8</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Dog&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;Pig&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;Rat&quot;</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    p[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">3</span>] == <span class="string">&quot;previous&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((x - y) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x - t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((y - x) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;\</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x + t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(p[<span class="string">&quot;Elsie&quot;</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3745-牛的学术圈-I—原题链接"><a href="#AcWing-3745-牛的学术圈-I—原题链接" class="headerlink" title="AcWing 3745. 牛的学术圈 I—原题链接"></a>AcWing 3745. 牛的学术圈 I—<a href="https://www.acwing.com/problem/content/3748/">原题链接</a></h4><p>题目标签：双指针 | 模拟 | 枚举  </p>
<blockquote>
<p>思路：<br><strong>我愿称之为本周最难的题</strong><br>当然难的部分在于对于既定答案的判断对错方法，尽管很抽象但是逻辑性还是很强的<br>首先我们知道可以最多改变l次，在排好序的基础上，我们希望能充分利用这l次+1的机会就必须在同一段上，并且加上这一段之后h可以有效的加一<br>顺着这个思路，假定我们遍历到了h，我们需要先定位到值为h-1的部分（i指针）。在定位到大于等于h-1的部分（j指针），此时区间被分为3部分：<br>1-j的部分：这部分的值<strong>恒大于等于h</strong>，也就是从j开始向左的所有数都不需要变化<br>j-i的部分：这部分的值<strong>都大于等于h-1</strong>，也就是从i开始到j（不包含j）的所有数是<strong>需要变化的数</strong><br>i-n的部分：这部分就算加了1也达不到h，也就是不需要变化的部分<br>如果我们假定的h成立，在将(j, i]的数加一之后，前h个数一定能保证大于h，也就是这个h成立了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>, q+<span class="number">1</span>+n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=n; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假定当h等于i成立时</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; q[j] &lt; i) j--; <span class="comment">//找到大于等于h的那个点（不需要改变的左端点）</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt;= i - <span class="number">1</span> &amp;&amp; i - j &lt;= k) res = i;<span class="comment">//保证q(j, i]中加一能大于等于i，并且这个区间的长度长度等于k</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AcWing-1459-奶牛体操—原题链接"><a href="#AcWing-1459-奶牛体操—原题链接" class="headerlink" title="AcWing 1459. 奶牛体操—原题链接"></a>AcWing 1459. 奶牛体操—<a href="https://www.acwing.com/problem/content/1461/">原题链接</a></h4><p>题目标签：枚举  </p>
<blockquote>
<p>思路：<br>满足题意的条件是，任意两个数，在所有排名中的先后次序都是一样的，其中一方指向另一方的方向不会变，因此可以开一个二位数组，横坐标指向纵坐标表示一次排名。<br>遍历结束后，如果只有一方指向另一方而没有反过来的方向，则成立。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                st[a[i]][a[j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]^ st[j][i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题-2-第三周</title>
    <url>/2022/04/11/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第三周题解</p>
<span id="more"></span>
<h4 id="AcWing-1683-困牛放牧—原题链接"><a href="#AcWing-1683-困牛放牧—原题链接" class="headerlink" title="AcWing 1683. 困牛放牧—原题链接"></a>AcWing 1683. 困牛放牧—<a href="https://www.acwing.com/problem/content/1685/">原题链接</a></h4><p>题目标签：  </p>
<blockquote>
<p>思路：<br>分情况讨论即可<br>对于最小的情况，如果三者已经连续了，那便不需要调整，如果两两之间有唯一空位，填充空位即可，否则只需要第一次将端点移到空一位的地方，接着填充即可<br>对u有最大的情况，从不相连到相连的过程就是填充点和点之间的距离，输出两个线段最长的一段的距离也就是要填充的最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; abs(a - b) - 1 &lt;&lt; &quot;-&quot; &lt;&lt; abs(b - c) - 1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span> == <span class="number">1</span> || <span class="built_in">abs</span>(b - c) - <span class="number">1</span> == <span class="number">1</span>)  <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(b - c) - <span class="number">1</span> == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span>, <span class="built_in">abs</span>(b - c) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1470-水桶传递队列—原题链接"><a href="#AcWing-1470-水桶传递队列—原题链接" class="headerlink" title="AcWing 1470. 水桶传递队列—原题链接"></a>AcWing 1470. 水桶传递队列—<a href="https://www.acwing.com/problem/content/1472/">原题链接</a></h4><p>题目标签：BFS  </p>
<blockquote>
<p>思路：<br>知道了起点和终点求最短路，直接BFS即可，模板题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line">PII st, ed;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    dist[st.first][st.second] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.first + dx[i], b = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= <span class="number">10</span> &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= <span class="number">10</span> &amp;&amp; g[a][b] != <span class="string">&#x27;R&#x27;</span> &amp;&amp; dist[a][b] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = dist[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a == ed.first &amp;&amp; b == ed.second) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c = s[j];</span><br><span class="line">            g[i][j+<span class="number">1</span>] = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span>) st = &#123;i, j+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;B&#x27;</span>) ed = &#123;i, j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; dist[ed.first][ed.second]<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1761-阻挡广告牌—原题链接"><a href="#AcWing-1761-阻挡广告牌—原题链接" class="headerlink" title="AcWing 1761. 阻挡广告牌—原题链接"></a>AcWing 1761. 阻挡广告牌—<a href="https://www.acwing.com/problem/content/1763/">原题链接</a></h4><p>题目标签：暴力 | 区间求交集 | 计算几何  </p>
<blockquote>
<p>思路：<br>因为两个广告牌互不相交，所以求分别相交的两个部分即可，平面中香蕉部分即右端点的最小值*左端点的最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(b, d) - <span class="built_in">max</span>(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">(<span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">2</span>] - a[<span class="number">0</span>]) * (a[<span class="number">3</span>] - a[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">get</span>(a[i][<span class="number">0</span>], a[i][<span class="number">2</span>], a[<span class="number">2</span>][<span class="number">0</span>], a[<span class="number">2</span>][<span class="number">2</span>]) * <span class="built_in">get</span>(a[i][<span class="number">1</span>], a[i][<span class="number">3</span>], a[<span class="number">2</span>][<span class="number">1</span>], a[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">area</span>(a[<span class="number">0</span>]) + <span class="built_in">area</span>(a[<span class="number">1</span>]) - res &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1749-阻挡广告牌-II—原题链接"><a href="#AcWing-1749-阻挡广告牌-II—原题链接" class="headerlink" title="AcWing 1749. 阻挡广告牌 II—原题链接"></a>AcWing 1749. 阻挡广告牌 II—<a href="https://www.acwing.com/problem/content/1751/">原题链接</a></h4><p>题目标签：模拟 | 分类讨论（不推荐）  </p>
<blockquote>
<p>思路：<br>看样子是个分类讨论，但是一方面需要分不少类，另一方面数据并不大，因此直接上暴力模拟，需要注意的是边转换为方格时的边界问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, B = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    a += B, b += B, c += B, d += B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a; i&lt;c; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=b; j&lt;d; j++) st[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    a += B, b += B, c += B, d += B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a; i&lt;c; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=b; j&lt;d; j++) st[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    a = b = N, c = d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, i);</span><br><span class="line">                b = <span class="built_in">min</span>(b, j);</span><br><span class="line">                c = <span class="built_in">max</span>(c, i);</span><br><span class="line">                d = <span class="built_in">max</span>(d, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(<span class="number">0</span>, d - b + <span class="number">1</span>), height = <span class="built_in">max</span>(<span class="number">0</span>, c - a + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; len * height &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1737-传送—原题链接"><a href="#AcWing-1737-传送—原题链接" class="headerlink" title="AcWing 1737. 传送—原题链接"></a>AcWing 1737. 传送—<a href="https://www.acwing.com/problem/content/1739/">原题链接</a></h4><p>题目标签：分类讨论  </p>
<blockquote>
<p>思路：<br>也就三种情况，应该是某复杂最短路题目的阉割版</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="built_in">abs</span>(a - b);</span><br><span class="line">    <span class="type">int</span> d2 = <span class="built_in">abs</span>(a - x) + <span class="built_in">abs</span>(y - b);</span><br><span class="line">    <span class="type">int</span> d3 = <span class="built_in">abs</span>(a - y) + <span class="built_in">abs</span>(x - b);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d1, <span class="built_in">min</span>(d2, d3)) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1725-组队井字游戏—原题链接"><a href="#AcWing-1725-组队井字游戏—原题链接" class="headerlink" title="AcWing 1725. 组队井字游戏—原题链接"></a>AcWing 1725. 组队井字游戏—<a href="https://www.acwing.com/problem/content/1727/">原题链接</a></h4><p>题目标签：模拟 | 暴力  </p>
<blockquote>
<p>思路：<br>因为只有3x3的棋盘，所以直接暴力模拟一次就可以了，这里可以巧妙的运用set的自动查重</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">set&lt;set&lt;<span class="type">char</span>&gt;&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(g[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(g[<span class="number">0</span>][<span class="number">0</span>]);s.<span class="built_in">insert</span>(g[<span class="number">1</span>][<span class="number">1</span>]); s.<span class="built_in">insert</span>(g[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(g[<span class="number">2</span>][<span class="number">0</span>]);s.<span class="built_in">insert</span>(g[<span class="number">1</span>][<span class="number">1</span>]); s.<span class="built_in">insert</span>(g[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl &lt;&lt; s2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题-2-第四周</title>
    <url>/2022/04/11/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第二周题解</p>
<span id="more"></span>
<h4 id="AcWing-1812-方形牧场—原题链接"><a href="#AcWing-1812-方形牧场—原题链接" class="headerlink" title="AcWing 1812. 方形牧场—原题链接"></a>AcWing 1812. 方形牧场—<a href="https://www.acwing.com/problem/content/1814/">原题链接</a></h4><p>题目标签：枚举  </p>
<blockquote>
<p>思路：<br>暴力枚举即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    x1 = y1 = <span class="number">15</span>, x2 = y2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a1, b1, c1, d1, a2, b2, c2, d2;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; d1 &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; c2 &gt;&gt; d2;</span><br><span class="line">    x1 = <span class="built_in">min</span>(x1, <span class="built_in">min</span>(a1, <span class="built_in">min</span>(c1, <span class="built_in">min</span>(a2, c2))));</span><br><span class="line">    y1 = <span class="built_in">min</span>(y1, <span class="built_in">min</span>(b1, <span class="built_in">min</span>(d1, <span class="built_in">min</span>(b2, d2))));</span><br><span class="line">    x2 = <span class="built_in">max</span>(x2, <span class="built_in">max</span>(a1, <span class="built_in">max</span>(c1, <span class="built_in">max</span>(a2, c2))));</span><br><span class="line">    y2 = <span class="built_in">max</span>(y1, <span class="built_in">max</span>(b1, <span class="built_in">max</span>(d1, <span class="built_in">max</span>(b2, d2))));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">max</span>(<span class="built_in">abs</span>(x2 - x1), <span class="built_in">abs</span>(y2 - y1));</span><br><span class="line">    cout &lt;&lt; n * n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1800-不做最后一个！—原题链接"><a href="#AcWing-1800-不做最后一个！—原题链接" class="headerlink" title="AcWing 1800. 不做最后一个！—原题链接"></a>AcWing 1800. 不做最后一个！—<a href="https://www.acwing.com/problem/content/1802/">原题链接</a></h4><p>题目标签：  </p>
<blockquote>
<p>思路：<br>n不大于100，因此直接暴力，非常滴暴力且不聪明</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;daaaaaaa</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; mp = &#123;&#123;<span class="string">&quot;Bessie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Elsie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Daisy&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Gertie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Annabelle&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Maggie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Henrietta&quot;</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line">        mp[s] += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; v1;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, t.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.second != minn) v1.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; v2;</span><br><span class="line">    minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, v1[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = v1[i];</span><br><span class="line">        <span class="keyword">if</span>(t.second == minn) v2.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v2.<span class="built_in">size</span>() == <span class="number">1</span>) cout &lt;&lt; v2[<span class="number">0</span>].first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1788-牛为什么过马路—原题链接"><a href="#AcWing-1788-牛为什么过马路—原题链接" class="headerlink" title="AcWing 1788. 牛为什么过马路—原题链接"></a>AcWing 1788. 牛为什么过马路—<a href="https://www.acwing.com/problem/content/description/1790/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>直接模拟</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(p[a] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[a] != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1775-丢失的牛—原题链接"><a href="#AcWing-1775-丢失的牛—原题链接" class="headerlink" title="AcWing 1775. 丢失的牛—原题链接"></a>AcWing 1775. 丢失的牛—<a href="https://www.acwing.com/problem/content/1777/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：直接模拟就行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dist, now, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">0</span>, step = <span class="number">1</span>, last = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> next = x + step;</span><br><span class="line">        <span class="keyword">if</span>((y &gt;= last &amp;&amp; y &lt;= next) || (y &gt;= next &amp;&amp; y &lt;= last))</span><br><span class="line">        &#123;</span><br><span class="line">            dist += <span class="built_in">abs</span>(last - y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dist += <span class="built_in">abs</span>(last - next);</span><br><span class="line">        step *= (<span class="number">-2</span>);</span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dist &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1866-围栏刷漆—原题链接"><a href="#AcWing-1866-围栏刷漆—原题链接" class="headerlink" title="AcWing 1866. 围栏刷漆—原题链接"></a>AcWing 1866. 围栏刷漆—<a href="https://www.acwing.com/problem/content/description/1868/">原题链接</a></h4><p>题目标签：集合  </p>
<blockquote>
<p>思路：<br>虽然可以暴力模拟，但是集合才应该是本题的考点，两个线段集合在确定头部关系的情况下只有包含，重合，不重合三种情况，分类讨论即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a, c);</span><br><span class="line">        <span class="built_in">swap</span>(b, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; d)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b + d - a - c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b - a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d - a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1854-晋升计数—原题链接"><a href="#AcWing-1854-晋升计数—原题链接" class="headerlink" title="AcWing 1854. 晋升计数—原题链接"></a>AcWing 1854. 晋升计数—<a href="https://www.acwing.com/problem/content/1856/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>模拟 × 阅读理解 √， 并且使用n是为了兼容比赛组别不一定为4的情况</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    res[n] = b[n] - a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = res[i+<span class="number">1</span>] + b[i] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第二周</title>
    <url>/2022/03/26/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第二周题解</p>
<span id="more"></span>
<h4 id="AcWing-1442-单词处理器—原题链接"><a href="#AcWing-1442-单词处理器—原题链接" class="headerlink" title="AcWing 1442. 单词处理器—原题链接"></a>AcWing 1442. 单词处理器—<a href="https://www.acwing.com/problem/content/1444/">原题链接</a></h4><p>题目标签：字符串 | 模拟  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，派大星看了都会（向派大星道歉）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(now + s.<span class="built_in">size</span>() &lt;= k) now += s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            now = s.<span class="built_in">size</span>();</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-1671-三角形—原题链接"><a href="#AcWing-1671-三角形—原题链接" class="headerlink" title="AcWing 1671. 三角形—原题链接"></a>AcWing 1671. 三角形—<a href="https://www.acwing.com/problem/content/1673/">原题链接</a></h4><p>题目标签：暴力 | 枚举  </p>
<blockquote>
<p>思路：<br>恩枚举就完了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line">vector&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;q.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;q.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;q.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j || j==k || i==k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[i].first == q[j].first &amp;&amp; q[j].second == q[k].second)</span><br><span class="line">                        res = <span class="built_in">max</span>(res, <span class="built_in">abs</span>(q[j].first - q[k].first) * <span class="built_in">abs</span>(q[j].second - q[i].second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1659-社交距离-I—原题链接"><a href="#AcWing-1659-社交距离-I—原题链接" class="headerlink" title="AcWing 1659. 社交距离 I—原题链接"></a>AcWing 1659. 社交距离 I—<a href="https://www.acwing.com/problem/content/1661/">原题链接</a></h4><p>题目标签：分类讨论 | 模拟 | （也可以）二分  </p>
<blockquote>
<p>思路：<br>两头牛能摆放的情况，除了原先一头牛也没有之外，只有两种情况：<br>1、两头牛在同一去年内<br>2、两头牛分别在不同区间<br>算出这两种情况下的取值，取最大值的那个方案即为所需要的方案（输出时要和原先区间的最小值做比对并取最小值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) p[++cnt] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) cout &lt;&lt; n<span class="number">-1</span> &lt;&lt; endl; <span class="comment">//如果原先的序列里一头牛都没有</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xmin = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) xmin = <span class="built_in">min</span>(xmin, p[i+<span class="number">1</span>] - p[i]); <span class="comment">// 原先区间中距离的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两头牛在同一区间的方案</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">max</span>((p[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>, (n-p[cnt])/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) y = <span class="built_in">max</span>(y, (p[i+<span class="number">1</span>]-p[i])/<span class="number">3</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两头牛在不同区间的方案</span></span><br><span class="line">        <span class="type">int</span> y1 = p[<span class="number">1</span>]<span class="number">-1</span>, y2 = n-p[cnt];</span><br><span class="line">        <span class="keyword">if</span>(y1 &lt; y2) <span class="built_in">swap</span>(y1, y2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = (p[i+<span class="number">1</span>]-p[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= y1) y2 = y1, y1 = d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; y2) y2 = d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(xmin, <span class="built_in">max</span>(y, y2)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=cnt; i++) cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1714-混合牛奶—原题链接"><a href="#AcWing-1714-混合牛奶—原题链接" class="headerlink" title="AcWing 1714. 混合牛奶—原题链接"></a>AcWing 1714. 混合牛奶—<a href="https://www.acwing.com/problem/content/1716/">原题链接</a></h4><p>题目标签：模拟 | 找规律（做的时候没找到…）  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，这里面有规律可以找不过只需要操作100次因此恩模拟也没问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acow</span></span><br><span class="line">&#123;</span><br><span class="line">    PII a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acow cow;</span><br><span class="line">    cin &gt;&gt; cow.a.first &gt;&gt; cow.a.second &gt;&gt; cow.b.first &gt;&gt; cow.b.second &gt;&gt; cow.c.first &gt;&gt; cow.c.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1 -&gt; 2</span></span><br><span class="line">            <span class="keyword">if</span>(cow.a.second + cow.b.second &lt;= cow.b.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second += cow.a.second;</span><br><span class="line">                cow.a.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second -= cow.b.first -  cow.b.second;</span><br><span class="line">                cow.b.second = cow.b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2 -&gt; 3</span></span><br><span class="line">            <span class="keyword">if</span>(cow.b.second + cow.c.second &lt;= cow.c.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second += cow.b.second;</span><br><span class="line">                cow.b.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second -= cow.c.first - cow.c.second;</span><br><span class="line">                cow.c.second = cow.c.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//3 -&gt; 1</span></span><br><span class="line">            <span class="keyword">if</span>(cow.c.second + cow.a.second &lt;= cow.a.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second += cow.c.second;</span><br><span class="line">                cow.c.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second -= cow.a.first - cow.a.second;</span><br><span class="line">                cow.a.second = cow.a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cow.a.second &lt;&lt; endl &lt;&lt; cow.b.second &lt;&lt; endl &lt;&lt; cow.c.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1695-果壳游戏—原题链接"><a href="#AcWing-1695-果壳游戏—原题链接" class="headerlink" title="AcWing 1695. 果壳游戏—原题链接"></a>AcWing 1695. 果壳游戏—<a href="https://www.acwing.com/problem/content/1697/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>将三个杯子预定义好，按照题目的要求进行交换，点中的杯子就杯子内容+1，也就是说如果这个杯子里提前放了鹅卵石那他就能猜对，最后输出最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">swap</span>(p[a], p[b]);</span><br><span class="line">        ans[p[c]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(ans+<span class="number">1</span>, ans+<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>VFIT - 基于Transformer的视频插帧模型</title>
    <url>/2023/12/14/CV%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/VFIT-%E5%9F%BA%E4%BA%8ETransformer%E7%9A%84%E8%A7%86%E9%A2%91%E6%8F%92%E5%B8%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>基于Transformer的视频插帧模型</p>
<span id="more"></span>
<p>Title：Video Frame Interpolation Transformer</p>
<p>major：CV</p>
<p>Author：Zhihao Shi, Xiangyu Xu, Xiaohong Liu, Jun Chen, Ming-Hsuan Yang</p>
<p>Push：CVPR 2022</p>
<p>paper：<a href="https://openaccess.thecvf.com/content/CVPR2022/papers/Shi_Video_Frame_Interpolation_Transformer_CVPR_2022_paper.pdf">https://openaccess.thecvf.com/content/CVPR2022/papers/Shi_Video_Frame_Interpolation_Transformer_CVPR_2022_paper.pdf</a></p>
<p>code：<a href="https://github.com/zhshi0816/Video-Frame-Interpolation-Transformer">https://github.com/zhshi0816/Video-Frame-Interpolation-Transformer</a></p>
<p>简介：</p>
<p>论文提出了一种基于Transformer的视频帧插值框架（VFIT），用于解决视频插值的计算机视觉问题。该框架允许内容感知的聚合权重，并通过自注意操作考虑长距离依赖。为了避免全局自注意的高计算成本，作者引入了局部注意的概念并将其扩展到空间-时间域。此外，提出了一种节省内存的空间-时间分离策略，这也提高了性能。还开发了一种多尺度框架合成方案，以充分实现Transformer的潜力。广泛的实验表明，所提出的模型在多种基准数据集上在定量和定性方面均优于现有最先进的方法。</p>
<p>主要贡献：</p>
<ul>
<li>提出了新颖有效的视频插帧模型</li>
<li>提出了时空分离的局部注意力机制</li>
<li>提出了多尺度合成方案</li>
</ul>
<p>研究背景：</p>
<p>最常见的就是由30帧的视频变成60帧。该任务属于依赖性较强的生成问题，通过在现有帧之间合成新帧来时间上对输入视频进行上采样。</p>
<p>这是计算机视觉中的一个基本问题，涉及对运动结构和自然图像分布的理解，有助于诸如图像恢复、虚拟现实和医学成像等众多下游应用</p>
<p>研究限制：</p>
<p>视频信息由于其高纬度，复杂度和计算成本指数上升。当然可以粗暴的把视频作为更高纬度的图片，但是这样失去了很多信息例如时序信息。<br>CNN曾被用与视频分析，但是卷积操作与内容的时序变化不相关，再者卷积核大小直接影响结果且不能粗暴的通过增加数量来弥补。<br>大部分视频插帧模型不擅长处理复杂的纹理和运动。<br>Transformer由NLP改进至视觉领域，再从开销大的全局注意力优化至局部注意力。之前已经有人以此作过图像的研究，作者将其应用在视频上。</p>
<p>模型架构：</p>
<p>模型分为三部分</p>
<p>1、用3D卷积提取浅层特征</p>
<p>2、使用深层网络获取深层特征</p>
<p>3、使用SynBlocks生成新帧</p>
<p><img src="https://overdata-1305650175.cos.ap-chongqing.myqcloud.com/paper%2Fpic-forBLOG%2FVFIT-1.png" alt="VFIT-1"></p>
<p>方法论 - 局部注意力机制：</p>
<p>全局注意力开销大，虽然能用分块的方法解决但是影响质量<br>引入swin的局部注意力机制，但是并不能直接应用于视频<br>STS：把图3中4纬的图像分割为m<em>m进行第一次多头注意力，之后恢复原状，各边留出m&#x2F;2后重新分割之后再进行一次多头注意力<br>Sep-STS:对于空间，将特征图分成2D的块（分离时间），对于时间，将特征图分为T</em>T个向量（分离空间）<br>引入层正则化优化计算以及GELU激活函数</p>
<p><img src="https://overdata-1305650175.cos.ap-chongqing.myqcloud.com/paper%2Fpic-forBLOG%2FVFIT-2.png" alt="VFIT-2"></p>
<p>方法论 - 多尺度合成块：</p>
<p>SynBlocks之后的操作：上一层粗糙图像的上采样（双线性插值）和当前层block输出相加</p>
<p>SynBlocks的输入输出：1、对于l层特征，按帧抽出后放进三个卷积层2、卷积层输出的结果与原帧融合3、输出结果与特征直接卷积的值相乘4、最后将所有帧相加</p>
<p>实验细节：</p>
<p>模型训练：loss 绝对值损失、opt adamax、evaluate  PSNR&amp;SSIM、dataset Vimeo-90K 等<br>训练环境：desktop with an Intel Core i7-8700K CPU and an NVIDIA GTX 2080 Ti GPU<br>模型设计了基础版VFIT- B和简单版VFIT- S，与现有的模型做了对比实验。除此之外还做了消融实验。</p>
<p>结论：</p>
<p>本文提出了一种参数节省、运行高效的VFIT框架，用于视频帧插值，性能达到了最先进水平。<br>使用了时间空间分离的局部注意力机制，本想考虑时空特征的前提下节省计算成本，但是得到了更好的效果。<br>使用了多尺寸生成块，同时考虑多个维度的特征，结合原帧的基础上从粗糙到细致优化生成帧。</p>
<p>展望：</p>
<p>本文的损失函数是最简单的绝对值损失，并且只作用于结果部分。作者尝试分块计算损失值但并不是很理想。<br>本文使用的上下采样方式是双线性插值法，本以为用Transformer架构会更好但得到了较差的结果，这点具有研究价值。<br>本文不仅适用于简单的视频，还可以拓展到其他具有时序逻辑的应用上。并且本文是泛用的视频生成帧，可以试着专攻某一个固定的事物进行生成。</p>
]]></content>
      <categories>
        <category>CV计算机视觉</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习领域的Hello World - 从零实现手写数字识别</title>
    <url>/2023/10/18/CV%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%86%E5%9F%9F%E7%9A%84Hello-World-%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>校内的科普讲座中讲到了手写数字识别，可以说是所有炼丹的起点了，这里整理一下实现的过程，为新入门的同学们提供参考。</p>
<span id="more"></span>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>程序在python3.8的环境下运行，需要在环境中下载以下包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下为我自己的设备安装的指令</span></span><br><span class="line"><span class="comment"># 根据自身需求在https://pytorch.org/get-started/locally/中复制下载</span></span><br><span class="line">conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>

<h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>本文使用的手写数字识别项目没有使用任何深层次技术，使用最简单粗暴的多层感知机来实现，图像方面也没有经过任何预处理，算法也使用的最简单的入门算法，主要为了让新手更快上手。这里简单介绍一下模型和算法</p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>我们可以将模型堪称一个黑盒子，黑盒子里由无数旋钮来配置这个盒子的信息。盒子由输入和输出两部分组成，就像最简单的y&#x3D;x的函数一样，我们放进去一个数据，就能得到一个数据，而数据的产生就是由这些旋钮控制的。</p>
<p>最开始盒子里的旋钮是杂乱的随机数，我们怎没来让旋钮设置出准确的结果呢？我们准备一个输入和理应得到的正确答案，根据输入得到输出后和正确答案进行比较，根据二者的差距来调整旋钮，就像调整天平一样。</p>
<p>上文中，<strong>黑盒子</strong>指的就是模型，旋钮指的就是模型的<strong>参数</strong>。我们使用正确答案来调整模型这一过程我们称之为<strong>训练</strong>。人们认为多个线性层组成的曲线函数可以拟合现实中我们不知道的函数从而得到正确结果，训练就是让模型函数变得更贴合现实函数的过程。</p>
<h3 id="原理分析与代码讲解"><a href="#原理分析与代码讲解" class="headerlink" title="原理分析与代码讲解"></a>原理分析与代码讲解</h3><h4 id="导入库文件"><a href="#导入库文件" class="headerlink" title="导入库文件"></a>导入库文件</h4><p>我们如果从零开始写一个文件，其中的各种方法例如求导、矩阵运算等写起来费时费力不说，这些都是前辈们设计好的东西。我们为了避免造轮子，于是使用pytorch这个深度学习框架来进行作业。以下是我们用到的所有库文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入库文件</span></span><br><span class="line"><span class="keyword">import</span> torch  <span class="comment"># pytorch</span></span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST  <span class="comment"># MNIST数据集</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms  <span class="comment"># 图像预处理操作</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader  <span class="comment"># 数据加载器</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  <span class="comment"># 神经网络</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># 操作系统相关操作</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image <span class="comment"># 图片操作</span></span><br></pre></td></tr></table></figure>

<h4 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h4><p>模型的构成方式有很多，最简单的例如一个y&#x3D;x都可以称之为一个模型，因为模型的本质就是函数。我们这里的模型之所以叫做<strong>多层感知机</strong>是因为他是使用最简单的<strong>线性层</strong>来组成的。</p>
<p>线性层是什么呢？就像他的名字一样，是由线性代数中的矩阵组成的数据。<strong>每个线性层可以定义输入n个数据和输出m个数据，就像nxm的矩阵一样，我们可以将1xn的矩阵和线性层矩阵相乘得到1xm的矩阵</strong>，这些数据和输入数据进行矩阵相乘的运算，得到一组新的数据传播到下一层或者是输出，具体为何能这么运算大家可以复习一下线性代数中矩阵的知识点。</p>
<p>我们的数据是28x28的图片，也就是784个由0·255组成的矩阵数据。为了与之对应，我们使用了三层线性层，分别从784层映射到256层，从256层映射到64层，从64层映射到10层（因为我们有总计十个分类的图片集合）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module): <span class="comment"># pytorch要求我们设计模型时继承Module这个类</span></span><br><span class="line">    <span class="comment"># 这里初始化模型参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">256</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">10</span>)  <span class="comment"># 10个数字输出为10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里定义模型的输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">784</span>) <span class="comment"># 将28x28的矩阵拉伸为1x784的矩阵</span></span><br><span class="line">        x = torch.relu(self.linear1(x))</span><br><span class="line">        x = torch.relu(self.linear2(x))</span><br><span class="line">        x = torch.relu(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 构建模型，将模型放入现存</span></span><br><span class="line">net = Model()</span><br><span class="line">net.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>这里的relu是激活函数，激活函数是一种用来引入非线性因素的函数，否则我们的输出永远都是一个线性方程，为了让大家不要一次性吸收太多知识，这里不过多解释。</p>
<h4 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h4><p>我们刚刚降到了参数是用来控制模型输出的旋钮，那么我们<strong>每次调整旋钮的方式</strong>便可以理解为<strong>超参数</strong>，即人为控制的，在参数之上的参数。我们反复调整超参数的行为也就叫做炼丹。</p>
<p>学习率，表示的是每次调整旋钮旋转的距离，如果每次转的太小那我们很久之后才能找到最合适的位置，如果每次转的太大那我们可能一直在最合适位置的左右反复横跳。</p>
<p>损失函数，即计算输出值和正确答案损失了多少的函数，对比黑盒子比喻中比较的部分。损失函数由很多种，比如说我们可以简单暴力的求二者差的绝对值，因为他直观地代表了两者的差距。这里使用的<strong>交叉熵损失</strong>不作详细解释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = <span class="number">0.1</span> <span class="comment"># 学习率 即每次学习更新的距离</span></span><br><span class="line">num_epochs = <span class="number">30</span> <span class="comment"># 训练次数 即进行多少次训练</span></span><br><span class="line">batch_size = <span class="number">128</span> <span class="comment"># 每次训练时取出的数据数量</span></span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># 损失函数 交叉熵损失 相当于softmax + log + NLLLoss</span></span><br><span class="line">opt = torch.optim.SGD(net.parameters(), lr=lr)  <span class="comment"># 优化器 梯度下降优化 是一种根据导数方向决定正负的调整方法</span></span><br></pre></td></tr></table></figure>

<h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><p>数据集，即数据的集合，pytorch为我们提供了数据加载器这个类来处理数据，在分类任务中我们需要将许多图片划分为0-9九个分类。数据集中的原始数据自然是图片本身，即28x28的像素图片，除此之外还应该有这张图具体代表哪个数字，来让计算机判断。其中，我们一般将数据集分为训练集和测试集，前者负责训练而后者负责测试模型性能。</p>
<p>因为图片的存储是由许多像素点组成，为了让他们转换为我们方便操作的pytorch使用的数据类型，我们需要对他进行预处理，我们可以定义一个transform函数来预处理图片数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将0-255的PIL文件转换为0-1的tensor文件</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">train_data = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=trans) <span class="comment"># 载入训练数据集</span></span><br><span class="line">train_iter = DataLoader(train_data, shuffle=<span class="literal">True</span>) <span class="comment"># 载入训练数据加载器</span></span><br><span class="line">test_data = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=trans) <span class="comment"># 载入测试数据集</span></span><br><span class="line">test_iter = DataLoader(test_data, shuffle=<span class="literal">True</span>) <span class="comment"># 载入测试数据加载器</span></span><br></pre></td></tr></table></figure>

<p>注意这里的download指的是是否下载，因此第一次下载就够了，之后直接读取就好，数据下载在data文件夹里。我们可以查看一下数据集中的一些数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据集中的数据</span></span><br><span class="line"><span class="keyword">for</span> i, (X, Y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    <span class="built_in">print</span>(Y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p>训练模型可以理解为每次调整旋钮的过程，即可以分成运算结果，查找差距，调整参数三个部分。训练完我们可以在测试集上验证我们的模型的准确性，具体过程详见代码及注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练开始&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练部分</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>, epoch, <span class="string">&quot;轮训练开始！&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> index, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            x, y = x.to(torch.device(<span class="string">&quot;cuda&quot;</span>)), y.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">            opt.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">            y_ = net(x)  <span class="comment"># 使用模型运行数据</span></span><br><span class="line">            l = loss(y_, y)  <span class="comment"># 计算损失</span></span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">100</span> == <span class="number">0</span>: <span class="comment"># 没训练100个整数倍个数据时，输出当前loss值</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;loss = <span class="subst">&#123;l.item()&#125;</span>&#x27;</span>)</span><br><span class="line">            l.backward()  <span class="comment"># 梯度下降，反向传播求导</span></span><br><span class="line">            opt.step()  <span class="comment"># 模型参数更新</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>, epoch, <span class="string">&quot;轮训练结束！&quot;</span>)</span><br><span class="line">        <span class="comment"># 测试部分</span></span><br><span class="line">        correct = <span class="number">0</span>  <span class="comment"># 正确的个数</span></span><br><span class="line">        total = <span class="number">0</span>  <span class="comment"># 总数</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> index, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_iter):</span><br><span class="line">                x, y = x.to(torch.device(<span class="string">&quot;cuda&quot;</span>)), y.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">                out = net(x)</span><br><span class="line">                _, crr = torch.<span class="built_in">max</span>(out.data, dim=<span class="number">1</span>)</span><br><span class="line">                total += y.size(<span class="number">0</span>) <span class="comment"># 计算总数</span></span><br><span class="line">                correct += (crr == y).<span class="built_in">sum</span>().item() <span class="comment"># 计算正确的个数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;识别率为：<span class="subst">&#123;correct / total&#125;</span>&#x27;</span>)</span><br><span class="line">    torch.save(net.state_dict(), <span class="string">&quot;./model/model.pkl&quot;</span>) <span class="comment"># 存储模型 注意提前建立好model文件夹</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练结束&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h4><p>接下来我们尝试写一个简单应用来验证一下我们的模型是否正确，我们将通过画图软件使用黑白两种颜色来制作一个28x28的图片，写上一个数字命名为number.png（注意是黑色背景），用python读取之后让模型来判断是否正确。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">app</span>():</span><br><span class="line">    net.load_state_dict(torch.load(<span class="string">&quot;./model/model.pkl&quot;</span>)) <span class="comment"># 读取模型参数</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&quot;number.png&quot;</span>).convert(<span class="string">&quot;L&quot;</span>) <span class="comment"># 读取图片</span></span><br><span class="line">    <span class="comment"># img.show() # 展示图片</span></span><br><span class="line">    img = trans(img) <span class="comment"># 图片初始化</span></span><br><span class="line">    img.view(-<span class="number">1</span>, <span class="number">784</span>) <span class="comment"># 图片拉伸为1x784的矩阵</span></span><br><span class="line">    img = img.to(torch.device(<span class="string">&#x27;cuda&#x27;</span>))</span><br><span class="line">    result = net(img)</span><br><span class="line">    a, res = torch.<span class="built_in">max</span>(result.data, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;识别结果为: &quot;</span>, res.item())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 我们可以写一个main函数来控制训练和应用两部分的使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># train()</span></span><br><span class="line">    app()</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们已经完成了数字手写识别的编码，也完成了这个hello world的入门工程。经过几次测试可以看出，模型并不能很准确的识别出信息，就像我们作为人也不能从一个1x784的矩阵中判断出一个数字一样，这种编码失去了很多有用信息，如空间信息等。至于如何有效利用这些信息，就是大家日后深入了解的部分了。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件名称：MNIST数据集训练数字识别</span></span><br><span class="line"><span class="comment"># 创建日期：2023/10/18</span></span><br><span class="line"><span class="comment"># 更新如期：2023/10/18</span></span><br><span class="line"><span class="comment"># 包依赖：torch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入库文件</span></span><br><span class="line"><span class="keyword">import</span> torch  <span class="comment"># pytorch</span></span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST  <span class="comment"># MNIST数据集</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms  <span class="comment"># 图像预处理操作</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader  <span class="comment"># 数据加载器</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  <span class="comment"># 神经网络</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># 操作系统相关操作</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image <span class="comment"># 图片操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module): <span class="comment"># pytorch要求我们设计模型时继承Module这个类</span></span><br><span class="line">    <span class="comment"># 这里初始化模型参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">256</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">10</span>)  <span class="comment"># 10个数字输出为10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里定义模型的输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">784</span>) <span class="comment"># 将28x28的矩阵拉伸为1x784的矩阵</span></span><br><span class="line">        x = torch.relu(self.linear1(x))</span><br><span class="line">        x = torch.relu(self.linear2(x))</span><br><span class="line">        x = torch.relu(self.linear3(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型，将模型放入现存</span></span><br><span class="line">net = Model()</span><br><span class="line">net.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义超参数</span></span><br><span class="line">lr = <span class="number">0.1</span> <span class="comment"># 学习率 即每次学习更新的距离</span></span><br><span class="line">num_epochs = <span class="number">30</span> <span class="comment"># 训练次数 即进行多少次训练</span></span><br><span class="line">batch_size = <span class="number">128</span> <span class="comment"># 每次训练时取出的数据数量</span></span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># 损失函数 交叉熵损失 相当于softmax + log + NLLLoss</span></span><br><span class="line">opt = torch.optim.SGD(net.parameters(), lr=lr)  <span class="comment"># 优化器 梯度下降优化 是一种根据导数方向决定正负的调整方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 将0-255的PIL文件转换为0-1的tensor文件</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">train_data = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=trans) <span class="comment"># 载入训练数据集</span></span><br><span class="line">train_iter = DataLoader(train_data, shuffle=<span class="literal">True</span>, batch_size=batch_size) <span class="comment"># 载入训练数据加载器</span></span><br><span class="line">test_data = MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=trans) <span class="comment"># 载入测试数据集</span></span><br><span class="line">test_iter = DataLoader(test_data, shuffle=<span class="literal">True</span>, batch_size=batch_size) <span class="comment"># 载入测试数据加载器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 查看数据集中的数据</span></span><br><span class="line"><span class="comment"># for i, (x, y) in enumerate(train_iter):</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"><span class="comment">#     print(x)</span></span><br><span class="line"><span class="comment">#     print(y)</span></span><br><span class="line"><span class="comment">#     break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练开始&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练部分</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>, epoch, <span class="string">&quot;轮训练开始！&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> index, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            x, y = x.to(torch.device(<span class="string">&quot;cuda&quot;</span>)), y.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">            opt.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">            y_ = net(x)  <span class="comment"># 使用模型运行数据</span></span><br><span class="line">            l = loss(y_, y)  <span class="comment"># 计算损失</span></span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">100</span> == <span class="number">0</span>: <span class="comment"># 没训练100个整数倍个数据时，输出当前loss值</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;loss = <span class="subst">&#123;l.item()&#125;</span>&#x27;</span>)</span><br><span class="line">            l.backward()  <span class="comment"># 梯度下降，反向传播求导</span></span><br><span class="line">            opt.step()  <span class="comment"># 模型参数更新</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>, epoch, <span class="string">&quot;轮训练结束！&quot;</span>)</span><br><span class="line">        <span class="comment"># 测试部分</span></span><br><span class="line">        correct = <span class="number">0</span>  <span class="comment"># 正确的个数</span></span><br><span class="line">        total = <span class="number">0</span>  <span class="comment"># 总数</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="keyword">for</span> index, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_iter):</span><br><span class="line">                x, y = x.to(torch.device(<span class="string">&quot;cuda&quot;</span>)), y.to(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">                out = net(x)</span><br><span class="line">                _, crr = torch.<span class="built_in">max</span>(out.data, dim=<span class="number">1</span>)</span><br><span class="line">                total += y.size(<span class="number">0</span>) <span class="comment"># 计算总数</span></span><br><span class="line">                correct += (crr == y).<span class="built_in">sum</span>().item() <span class="comment"># 计算正确的个数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;识别率为：<span class="subst">&#123;correct / total&#125;</span>&#x27;</span>)</span><br><span class="line">    torch.save(net.state_dict(), <span class="string">&quot;./model/model.pkl&quot;</span>) <span class="comment"># 存储模型 注意提前建立好model文件夹</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练结束&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用测试</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app</span>():</span><br><span class="line">    net.load_state_dict(torch.load(<span class="string">&quot;./model/model.pkl&quot;</span>)) <span class="comment"># 读取模型参数</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&quot;number.png&quot;</span>).convert(<span class="string">&quot;L&quot;</span>) <span class="comment"># 读取图片</span></span><br><span class="line">    <span class="comment"># img.show() # 展示图片</span></span><br><span class="line">    img = trans(img) <span class="comment"># 图片初始化</span></span><br><span class="line">    img.view(-<span class="number">1</span>, <span class="number">784</span>) <span class="comment"># 图片拉伸为1x784的矩阵</span></span><br><span class="line">    img = img.to(torch.device(<span class="string">&#x27;cuda&#x27;</span>))</span><br><span class="line">    result = net(img)</span><br><span class="line">    a, res = torch.<span class="built_in">max</span>(result.data, dim=<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;识别结果为: &quot;</span>, res.item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以写一个main函数来控制训练和应用两部分的使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># train()</span></span><br><span class="line">    app()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CV计算机视觉</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>CV</tag>
        <tag>入门教程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础 | 1、基本数据结构与流程控制</title>
    <url>/2022/03/22/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="第一部分-Java的基本数据结构与流程控制"><a href="#第一部分-Java的基本数据结构与流程控制" class="headerlink" title="第一部分 Java的基本数据结构与流程控制"></a>第一部分 Java的基本数据结构与流程控制</h3><p>本文是建立在拥有一定C&#x2F;C++基础上介绍的<strong>主观性极强的</strong>个人学习笔记，以个人感受和心得为主。</p>
<span id="more"></span>
<h4 id="I-最简单的Java应用程序"><a href="#I-最简单的Java应用程序" class="headerlink" title="I 最简单的Java应用程序"></a>I 最简单的Java应用程序</h4><p>众所周知，任何编程语言都是从一句Hello World开始的，所以…  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Hello world!</span><br></pre></td></tr></table></figure>
<p>简单分析： </p>
<ul>
<li>package表明这个java程序包含在MyJava这个包里面，包可以理解为类的容器</li>
<li>public称为访问修饰符，表示访问权限的级别，与C++基本类似  </li>
<li>class表明这是一个java的类，由此可见Java相较于C++更加依赖类与对象的使用，其中类的标识符约定俗成为首字母大写</li>
<li>println与C++中的printf或cout唯一不同的是，前者相当于输出后自动添加一个换行符，不需要的话同样有print方法可以使用  </li>
<li>java程序并不需要return 0，正常结束的java程序默认退出代码为0，若需要修改可以使用System.exit方法</li>
</ul>
<p>单从这一个Hello World来看，Java似乎并不是一个很简洁的语言（？），因为java十分注重类之间的包含和使用，因此在最开始会显得有些冗长，不过后续java的特点会慢慢展现出来，毕竟谁不喜欢int main（）呢<br>众所周知，读到这里你已经完全掌握了java并且可以找到不错的工作（不是），当然你也可以选择继续深入（<del>入土</del>）  </p>
<h4 id="II-注释"><a href="#II-注释" class="headerlink" title="II 注释"></a>II 注释</h4><p>java的注释继承了C++的注释方法，其中单行注释和多行注释完全一样，因此这里不做赘述，唯一的不同点在于java多了一项特殊的注释–文档注释  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 这是一份java的文档注释案例</span><br><span class="line">* @author Karuma</span><br><span class="line">* @version 1.0</span><br><span class="line">* @Update 2020/xx/xx</span><br><span class="line">* note：这家公司拖欠员工工资，赶紧跑路</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>值得一提的是，java可以根据文档注释的内容与关键字自动生成文档以及作者信息，这样即方便了项目管理也减轻了项目解释的工作  </p>
<h4 id="III-数据类型"><a href="#III-数据类型" class="headerlink" title="III 数据类型"></a>III 数据类型</h4><ul>
<li>整形：int、short、long、byte和C++在使用上几乎相同</li>
<li>浮点型：float、double和C++在使用上几乎相同</li>
<li>char：这里表示Unicode编码的字符单元的字符类型，可以简单理解为字符  </li>
<li>boolean：即C++的bool  </li>
<li>数组：与C++不同，java声明的方式为Templete[] name;此外，java的数组支持直接相互赋值（好耶）</li>
</ul>
<p>变量的声明与初始化、运算符类似于C++，不过常量的修饰符为final  </p>
<h4 id="IV-输入输出"><a href="#IV-输入输出" class="headerlink" title="IV 输入输出"></a>IV 输入输出</h4><p>对于java而言，标准输入流进行控制台输入需要以来Scanner类并与System.in关联，以下代码可以直观体现出Scanner的最基本的操作  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先的首先，使用Scanner类必须使用import引用java.util.Scanner</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//实例一个Scanner类的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请告诉我你的名字：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();<span class="comment">//将标准输入流的一行内容赋值给string类的对象name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你的名字是&quot;</span> + name);<span class="comment">//输出信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scanner对于数据的读入可以说相当方便，但是就安全性而言Console类更胜一筹，前者对于最基本的输入输出还是很便利的<br>Java的输出类似于C++中printf与cout的结合体，即支持简单的用+连接每个输出元素，又支持传统的占位符输出法  </p>
<h4 id="V-分支和循环"><a href="#V-分支和循环" class="headerlink" title="V 分支和循环"></a>V 分支和循环</h4><p>Java几乎完整延续了C++的流程控制语法，因此不多介绍</p>
<p>截止目前，Java和C++可以说是惊人的相似，我愿称之为C++++（C#：？）</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础_3_类的继承</title>
    <url>/2022/03/28/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-3-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="第三部分-类的继承"><a href="#第三部分-类的继承" class="headerlink" title="第三部分 类的继承"></a>第三部分 类的继承</h3><p>对于面向对象的程序设计而言，“继承”这个特点可以很直观的反应某个程序的框架与逻辑，另一方面，继承这个特点同样是程序设计语言中<strong>逐渐精简</strong>的特点的展现。  </p>
<span id="more"></span>
<h4 id="I-类-amp-超类-amp-子类"><a href="#I-类-amp-超类-amp-子类" class="headerlink" title="I 类&amp;超类&amp;子类"></a>I 类&amp;超类&amp;子类</h4><p>假如我们要设计很相似的两个类，这两个类的大部分属性和方法都一样，只是其中一个类相比于另一个多了几个属性和方法。此时如果将两个类同时写出来很明显存在代码重复的问题，这在程序设计中是很不建议的，因此可以用到继承这一概念。<br>以经理Manager与普通员工Employee举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新增的域和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字extends类似于C++中的冒号，表明正在基于已经存在的一个类（超类，基类。父类）来创造一个新的类（子类，派生类，孩子类）。<br>其中，子类不能直接访问父类的私有域，只有通过父类的公共接口才能访问。如果在方法中覆盖父类的方法并调用这个方法（我们希望调用父类的功能），并且由于子类也有这样的方法，就会无限调用下去直到程序崩溃，为此，我们可以使用关键字super来覆盖已有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决覆盖的问题，C++中需要写出整个父类的名称，而Java中super关键字直观的告诉我们，这个地方使用的是父类的方法，因此不会造成死循环。在子类中我们可以增加域，方法或者覆盖超类的方法，然而绝对不能删除继承的任何域和方法。<br>this作为隐式参数这个关键字有两个用途，一是可以被引用，二是调用该类的其他构造器，同样的super也作为一个隐式参数不光可以被引用，也可以调用父类的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//super必须放在构造器的最前面</span></span><br><span class="line">        <span class="built_in">super</span>(name, salary, year, month, day);</span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用for-each循环的时候，在调用父类和子类同名不同功能的方法时，虚拟机会自己判断对象是父类还是子类再进行相应的调用。<br>一个对象变量可以指示多种实际类型的现象成为<strong>多态</strong>，在与运行时能够自动选择调用的方法的现象称为<strong>动态绑定</strong>。如果是private，static，final的方法被称为<strong>静态绑定</strong>。<br>在Java中，对象变量是多态的，一个Employee对象即可以引用一个Employee对象，也可以引用Employee子类的对象，反之则不可以，并且调用方法的时候遵循哪个类的对象才可以调用哪个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关于类的强制类型转换，只能自顶向下进行转换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Employee类的对象变量引用boss，可以运行</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">staff</span> <span class="operator">=</span> boss;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Manager类的对象变量引用worker，不能运行</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">errorBoss</span> <span class="operator">=</span> worker;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以用boss调用专属于Manager的方法，而staff不可以</span></span><br><span class="line">        <span class="comment">//即使他们引用的是同一个对象</span></span><br><span class="line">        boss.setBonus(<span class="number">5000</span>); <span class="comment">// OK</span></span><br><span class="line">        staff.setBonus(<span class="number">5000</span>); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不允许被扩展的类被称为final类，在定义类的时候添加final修饰符即可，同理，不允许被覆盖的方法被称为final方法。<br>如果两个相似的子类需要输出一串简介信息，但是内容相差比较大，对于父类来说不太容易定义这个看似关联实则区别比较大的方法，这里就可以用到<strong>抽象类</strong>这个概念：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父类中创建抽象方法后，在子类中重载即可。</span></span><br><span class="line">    <span class="comment">// 类比于C++中的：virtual string getDescription() = 0;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自下而上的继承中，位于上层的类更通用的同时也更抽象，因此抽象abstract这个关键字就很好的解决了这个问题.<br>对于java中的访问，有以下四种情况：  </p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">子类</th>
<th align="center">所有类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h4 id="II-所有类的父类-Object"><a href="#II-所有类的父类-Object" class="headerlink" title="II 所有类的父类 - Object"></a>II 所有类的父类 - Object</h4><p>在Java中，除了基本类型（数值，字符，布尔值）以外，所有的变量都是对象变量，包括我们常见的数组（包括对象数组和普通数组）都是扩展了Object类的对象。<br>Object类是所有类的父类，我们定义类的时候虽然没有写出”extends Object“，但实际上却有这个含义。<br>以下将介绍部分Object类提供的方法，关于处理线程的方法将在后续介绍：  </p>
<ul>
<li>equals：用于比较两个类是否相等，默认的比较方式是检查是否具有相同的引用，确认两个对象是否相等需要很多逻辑上的判断且子类需要先调用父类的equals。  </li>
<li>hashCode：返回对象的散列码，可以理解成对象的ID，默认的散列码为对象的存储地址。hashcode自定义散列码时要保证相同对象有相同散列码，也可以用静态方法Object.hash(需要比较的参数)来生成。  </li>
<li>toString：返回对象的字符串，默认是类的名字+地址，自定义这个方法是一种非常有用的调试工具，标准类库中有很多这样的方法重载  <h4 id="III-泛型数组列表-ArrayList-与包装器"><a href="#III-泛型数组列表-ArrayList-与包装器" class="headerlink" title="III 泛型数组列表(ArrayList)与包装器"></a>III 泛型数组列表(ArrayList)与包装器</h4>对于类似C++中的vector可变数组的操作，java中提供了ArrayList类，它是一个采用类型参数的泛型类，使用时需要用尖括号来定义对象的类型：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类比于C++的模板</span><br><span class="line">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>
ArrayList类和C++的vector极为相似，但是需要注意的是，java中没有运算符的重载，意味着不能通过[]来访问元素，并且访问和修改元素的操作需要get和set方法来实现。<br>除此之外，虽说在Java这个极度面向对象的设计语言中，基础数据类型不作为对象存在，不过我们可以用他们来制造属于他们的对象，也就是包装器，具体类型的包装器对应其英文拼写：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//包装器可以实现自动打包(装箱),等价于list.add(Integer.valueOf(3));</span><br><span class="line">list.add(3);</span><br><span class="line">//也可以实现自动拆箱，等价于list.get(i).intValue();</span><br><span class="line">int n = list.get(i);</span><br></pre></td></tr></table></figure>
除此之外，包装器还提供了许多实用的静态方法，如Integer类中的ParseInt(String)可以将字符串转换为整数并返回。  <h4 id="IV-可变参数的方法"><a href="#IV-可变参数的方法" class="headerlink" title="IV 可变参数的方法"></a>IV 可变参数的方法</h4>顾名思义，即参数不固定的例子，printf就是一个很好的例子:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的...是实际代码的一部分，表明可以接受任意数量的对象</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object...args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上，printf接收到的两个参数分别为fmt和Object[]数组，也就是说，对于使用者而言，Object…参数类型和Object[]完全一样。  <h4 id="V-继承的设计技巧"><a href="#V-继承的设计技巧" class="headerlink" title="V 继承的设计技巧"></a>V 继承的设计技巧</h4></li>
<li>将公共操作和域放在父类中  </li>
<li>非特殊情况下，不要使用protected</li>
<li>使用继承实现”is-a”的关系，构建成一棵树</li>
<li>除非所有的继承方法都有意义，否则不要使用继承</li>
<li>在重载方法的时候，不要改变预期的行为</li>
<li>使用多态，而非一连串的分支</li>
<li>不要过多使用反射库</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础 | 2、类与对象</title>
    <url>/2022/03/23/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="第二部分-类与对象"><a href="#第二部分-类与对象" class="headerlink" title="第二部分 类与对象"></a>第二部分 类与对象</h3><p>众所周知，“xxx是一门面向对象的编程语言”这句话折磨了许多初学面向对象的同学们（总之包括而我），因此，虽然这个说法非常不负责并且非常有问题，但是我需要直接了当的说：<strong>面向对象不就是结构体+函数吗</strong>（当然不是）  </p>
<span id="more"></span>
<h4 id="I-面向对象中java与C-的区别"><a href="#I-面向对象中java与C-的区别" class="headerlink" title="I 面向对象中java与C++的区别"></a>I 面向对象中java与C++的区别</h4><p>事实上，Java作为一个摒弃了指针的语言来讲，面向对象这部分与C++有着显著的不同，比如说在对象实例化的部分：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date birthday; // java:实例化一个Date对象，对象名称为birthday</span><br><span class="line">//然而在C++中的实际含义如下，尽管形式一样</span><br><span class="line">Date* birthday; // C++  </span><br></pre></td></tr></table></figure>
<p>并不只是面向对象这部分，Java中的变量并没有进行赋值，而是一个变量指向了一个数据，由此可见，与其说Java是摒弃了指针的语言，不如说是全程都在用（简化版的）指针的语言<del>（真香啊</del><br>在面向对象的程序中，应该尽量避免一个方法能够修改对象属性，甚至是直接访问对象属性，这都是不安全的，因此java类的设计通常有以下指定功能的方法：  </p>
<ul>
<li>构造器：最朴实无华的构造器，简单粗暴的new一个新对象，传统中的传统</li>
<li>静态工厂的构造器：不使用传统的构造器构造对象，而是使用这种特殊的方法（接口）构造一个新对象并且作为返回值可以赋值给对象变量  </li>
<li>更改器：看似是修改了对象的属性，其实是返回了一个属性不一样的新对象  </li>
<li>访问器：只访问对象而不修改对象的方法被称为访问器</li>
</ul>
<p>听起来似乎花里胡哨，但本质上他们都是一个类&#x2F;对象的方法罢了，只不过是人们根据他们的功能或特性起了一个（听起来很高端的）新名字，下面这个程序案例可以充分展示上述中三个新方法的使用：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里是静态工厂</span></span><br><span class="line">        <span class="comment">//使用静态工厂实例化一个表示现在日期的对象，对象名称为date</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过date对象，得到int型的月份和日期（这个月的第几天）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//date的日期更新为该月的第一天，也就是减去today再+1，赋值给date，再通过DayOfWeek类与方法返回星期数，并用value得到值</span></span><br><span class="line">        date = date.minusDays(today - <span class="number">1</span>); <span class="comment">// 这里是更改器</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> date.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue(); <span class="comment">// 这里是访问器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出表头，即格式部分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;value; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出日历主体，只要还在当月就继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(date.getMonthValue() == month)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出日期</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,date.getDayOfMonth());</span><br><span class="line">            <span class="comment">//判断是否为今天</span></span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfMonth() == today)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新date</span></span><br><span class="line">            date = date.plusDays(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Mon Tue Wed Thu Fri Sat Sun</span></span><br><span class="line"><span class="comment">      1   2   3   4   5   6 </span></span><br><span class="line"><span class="comment">  7   8   9  10  11  12  13 </span></span><br><span class="line"><span class="comment"> 14  15  16  17  18  19  20 </span></span><br><span class="line"><span class="comment"> 21  22  23* 24  25  26  27 </span></span><br><span class="line"><span class="comment"> 28  29  30  31 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用这些类，接口和方法，可以轻松处理日历的很麻烦的问题（尤其是不用考虑一大堆边界条件，因为大犇们已经提前造好轮子了），  </p>
<h4 id="II-用户自定义类"><a href="#II-用户自定义类" class="headerlink" title="II 用户自定义类"></a>II 用户自定义类</h4><p>与c++结构类似，其区别第一在于java的各种属性与方法有着很长的前缀，其二在于java在声明方法的时候定义方法。不过，前者只是将C++的访问权限展开罗列，后者将每个类定义在一个java文件中，所以综上所述java的自定义类和C++结构依然相似。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个最简单的java类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//field1</span></span><br><span class="line">    <span class="comment">//field2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//constructor1</span></span><br><span class="line">    <span class="comment">//constructor2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//method1</span></span><br><span class="line">    <span class="comment">//method2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止域值（对象的属性）出错或者随意修改，应该在针对一个属性拥有以下三个内容：</p>
<ul>
<li>一个私有的数据域  </li>
<li>一个公有的域访问器的方法  </li>
<li>一个公有的域更改器的方法</li>
</ul>
<p>这样有很多好处，一是内部实现不会影响其他代码，二是更改其可以执行错误检查<br>同时为了防止数据域的出错，在需要返回一个<strong>可变对象</strong>的时候需要进行克隆：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OutPut</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Date theDay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是不安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> theDay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) theday.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="III-静态域与静态方法"><a href="#III-静态域与静态方法" class="headerlink" title="III 静态域与静态方法"></a>III 静态域与静态方法</h4><p>静态前缀修饰符static即将变量的作用域设置为静态，这个修饰符可以作用于以下内容：  </p>
<ul>
<li>静态域：</li>
</ul>
<p>将成员属性设置为静态，即<strong>类中所有对象都公用一个的属性</strong>，在其他面向对象的语言中也会将其称为“类域”，对于静态域的使用有以下经典用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动设置雇员的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态常量</li>
</ul>
<p>即在常量中用static修饰，最经典的例子就是在Math类中的静态常量PI。<br>静态常量因为不能被修改，所以设置成公有也是没有问题的。  </p>
<ul>
<li>静态方法</li>
</ul>
<p>静态方法是一种不能对对象实施操作的方法，也就是没有this参数的方法，例如，Math终端pow方法，在使用时不许呀哦任何Math对象。<br>虽然静态方法不能访问实例域，但是可以访问静态域，也可以通过类名待用这个方法。  </p>
<ul>
<li>静态工厂</li>
</ul>
<p>类似LocalDate和NumberFormat的类使用静态工厂方法来构建对象，以NumberFormat为例，不使用构造器有以下两点原因：<br>一方面构造器的名字必须与类名相同，而实际希望将得到两种不同的名字<br>另一方面使用构造器时无法改变所构造的对象类型，而Factory方法将返回一个DecimalFormat类的对象，也就是NumberFormat的子类。  </p>
<ul>
<li>main方法</li>
</ul>
<p>调用静态方法不需要对象，同理。main方法也是一个静态方法，main函数不需要对任何对象进行操作。<br>事实上，程序启动的时候没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。<br>注： 每一个类都可以有一个main方法，常用于对类进行单元测试</p>
<ul>
<li>声明时赋值与初始化块</li>
</ul>
<p>虽然java可以使用常规的构造器初始化数据域，与C++不同，java可以在类声明属性的时候就对其进行初始化，除此之华还有“初始化块”这个第三种机制，只要构造类的对象，这些块就会被执行，对于静态域进行初始化的初始化块可以在花括号前单独加一个static前缀<br>类中调用构造器的顺序为：<br>数据域初始化为默认值 -&gt; 按照声明中出现的次序执行初始化块 -&gt; 若构造器中有其他构造器，先执行内部构造器，再执行外部构造器</p>
<h4 id="IV-包"><a href="#IV-包" class="headerlink" title="IV 包"></a>IV 包</h4><p>包是java中管理类的容器，一个类可以使用<strong>所属包中的所有类</strong>，以及<strong>其他包中的公有类</strong>，我们可以有两种方法访问其他包中的类：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种方法 显然比较繁琐</span><br><span class="line">java.time.LocalDate todaty = java.time.LocalDate.now();</span><br><span class="line"></span><br><span class="line">第二种方法，*代表导入这个包内的所有类，当然也可以只导入特定的类</span><br><span class="line">import java.until.*;</span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">除此之外，import语句不仅可以导入类，还可以用来导入静态方法和静态域（不过这样会很大程度降低代码的清晰度）  </span><br><span class="line">同理，设计好的类也需要放在包中。可以用以下语句实现：  </span><br><span class="line">```java</span><br><span class="line">package nameOfpackage;</span><br></pre></td></tr></table></figure>

<p>如果在包的目录中没有对应的类，也可以进行编译，但是最终程序无法正常运行，因此需要先将所有类文件移到正确的位置上。<br>除此之外，类文件也可以存储在JAR文件中，JAR文件可以理解为Java归档的ZIP格式组织文件，JDK提供了许多JAR文件的类库，同时JAR文件也方便其他第三方库的使用。  </p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础 | 1、首次登陆的简单指令</title>
    <url>/2022/03/23/Linux_Basic/Linux%E5%9F%BA%E7%A1%80-1-%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86%E7%9A%84%E7%AE%80%E5%8D%95%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>虽然但是，第一次面对控制台的操作系统，即没有知识储备，又害怕不小心弄错了什么，那就从最简单的一些系统指令入手8</p>
<span id="more"></span>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="I-指令格式"><a href="#I-指令格式" class="headerlink" title="I 指令格式"></a>I 指令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user@name ~]$ command [options] parameter1 parameter2 …</span><br></pre></td></tr></table></figure>
<p>绝大多数指令遵循以上框架，其详细说明如下：  </p>
<ul>
<li>@前的user指的是用户名，@后的name指的是计算机的名称，~符号表明文件的home目录  </li>
<li>$符号指的是“提示字符”，表示可以开始输入指令，其中root的提示字符为#  </li>
<li>command指的是指令名称或可执行文件</li>
<li>options指的是选项设定，实际使用时不加[]而是大部分用-作为前缀  </li>
<li>parameter指的是指令的参数，以<strong>不计个数的空格</strong>区分  </li>
<li>指令输入完毕后，回车键表示执行指令，指令太长时使用反斜杠\来跳脱回车符号</li>
</ul>
<p>注：Linux指令严格区分大小写，空格和回车是很重要的字符。  </p>
<p>尝试以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al ~</span><br></pre></td></tr></table></figure>
<p>效果为列出home目录下的所有隐藏档与相关文件的属性<br>关于指令的严格区分大小写，以下案例可以充分展示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date //显示日期和实现</span><br><span class="line">Date //找不到指令</span><br><span class="line">DATE //找不到指令</span><br></pre></td></tr></table></figure>
<p>综上所述，大小写在Linux中是有很大区别的。  </p>
<h4 id="II-语系"><a href="#II-语系" class="headerlink" title="II 语系"></a>II 语系</h4><p>由于Linux是支持多国语系的，如果系统默认设置下无法支持以中文编码输出数据，我们需要自行将支持语系改为英文，可以用到以下指令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale //显示目前支持的语系</span><br></pre></td></tr></table></figure>
<p>LANG 指语言语系的输出<br>LC_TIME 指时间方面的语系数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=en_US.utf8 //更改输出信息的语系</span><br><span class="line">export LC_ALL=en_US.utf8 //同步更新LC_ALL</span><br></pre></td></tr></table></figure>
<p>通过以上设置，就能够在本次登入中查看英文信息了  </p>
<h4 id="III-基础指令操作"><a href="#III-基础指令操作" class="headerlink" title="III 基础指令操作"></a>III 基础指令操作</h4><ul>
<li>显示日期的指令 date</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>不加任何参数的date指令可以输出当前时间，且格式为星期+月+日+时+分+秒+时区+年份<br>当然也可以输入带有参数的指令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +%Y/%m/%d //显示为 年/月/日</span><br><span class="line">date +%H:%M //显示为 时：分</span><br></pre></td></tr></table></figure>
<p>其中，第一行命令中的选项部分不一定以-开头，也可以由+开头  </p>
<ul>
<li><p>显示日历的指令 cal  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cal //直接输出本月的日历</span><br><span class="line">cal 2015 //输出2015年一整年的日历</span><br></pre></td></tr></table></figure>
<p>基本上cal这个命令可以接的语法为cal [month] [year]<br>当然如果输入了不存在的月份会出现对应的错误提示，对于Linux指令而言，指令反馈的错误是debug的一大关键信息  </p>
<h4 id="VI-重要的热键"><a href="#VI-重要的热键" class="headerlink" title="VI 重要的热键"></a>VI 重要的热键</h4></li>
<li><p>Tab 类似于在IDE中，在Linux命令行中Tab主要负责“补全”这一功能  </p>
<ol>
<li>在command部分中使用tab代表命令补齐，即输出所有满足已经输入部分文字为开头的指令  </li>
<li>在之后的部分使用tab代表文件&#x2F;参数&#x2F;选项补齐，具体依情况而定</li>
</ol>
</li>
<li><p>ctrl+c 终端目前程序，常用来跳出死循环  </p>
</li>
<li><p>ctrl+d 离开程序或输入结束，可以用来代替exit  </p>
</li>
<li><p>shift+pageup&#x2F;down 前后翻页</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>html与CSS实现带下拉菜单的导航栏</title>
    <url>/2022/05/30/Web%E7%BD%91%E9%A1%B5/html%E4%B8%8ECSS%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<p>使用html和CSS实现简单带下拉二级菜单的导航栏</p>
<span id="more"></span>
<h3 id="带下拉菜单导航栏的制作"><a href="#带下拉菜单导航栏的制作" class="headerlink" title="带下拉菜单导航栏的制作"></a>带下拉菜单导航栏的制作</h3><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>菜单栏布局：弹性盒子+列表+超链接</p>
<p>悬浮于窗口：绝对定位</p>
<p>下拉实现：元素y轴缩放</p>
<h4 id="文本部分"><a href="#文本部分" class="headerlink" title="文本部分"></a>文本部分</h4><p>使用两个div区分空间，分别为导航栏的背景和内容区域，菜单部分使用列表实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu_background&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu_area&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu_list&quot;</span>&gt;</span><span class="comment">&lt;!--菜单部分--&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而菜单内容的具体部分，我们使用li标签嵌套a标签实现跳转功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_text_a&quot;</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而下拉的二级菜单则是在这个li中再嵌套一个列表，我们这里使用有序列表和一级菜单进行区分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_text_a&quot;</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_a&quot;</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="文本位置调整"><a href="#文本位置调整" class="headerlink" title="文本位置调整"></a>文本位置调整</h4><p>因为很多元素默认自带内外边距，种类多了会很麻烦，所以提前将所有元素的内外边距归零，有需要的时候再做调整</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先确定出整个导航栏的背景，使用绝对定位让他相对浏览器窗口固定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_background</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">position</span>: fixed; // 元素位置设置为绝对定位</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">10</span>; // 使导航栏悬浮在内容上方</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">3px</span> <span class="built_in">rgb</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用弹性布局将纵向显示的导航栏改为横向，设置列表元素大小填充父元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_area</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; // 填充父元素</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; // 显示为弹性布局</span><br><span class="line">    <span class="attribute">list-style</span>: none; // 取消列表表头</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上边的方法设置二级菜单</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nemu_dropdown_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>; // 因为导航栏的高度是<span class="number">50px</span>，所以下拉菜单也这样设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为跳转功能是使用a标签实现的，所以对一二级菜单的a标签进行设置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//基础设置两个地方的<span class="selector-tag">a</span>标签相同，这里以一级菜单的<span class="selector-tag">a</span>标签为例</span><br><span class="line"><span class="selector-class">.menu_text_a</span></span><br><span class="line">&#123;</span><br><span class="line">    // 因为<span class="selector-tag">a</span>标签是行内元素，我们需要把他显示为块元素才能设置宽高</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: black; // 取消<span class="selector-tag">a</span>标签自带的颜色</span><br><span class="line">    <span class="attribute">text-decoration</span>: none; // 取消下划线</span><br><span class="line">    <span class="attribute">text-align</span>: center; // 水平居中</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>; // 设置行间距，使其垂直居中</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现下拉功能"><a href="#实现下拉功能" class="headerlink" title="实现下拉功能"></a>实现下拉功能</h4><p>使用缩放实现下拉和关闭，因此在下拉菜单部分写上下拉内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    // 核心代码 下拉实现的原理</span><br><span class="line">    // 我们将列表收缩为<span class="number">0</span> 在我们看来也就是消失了 需要时展开为<span class="number">1</span>即可</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>); // 在y轴上收缩为<span class="number">0</span></span><br><span class="line">    // 元素默认变化位置在元素中心</span><br><span class="line">    // 为了表现出下拉的动画，我们将位置设置为元素上方</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.6s</span>; // 所有动画触发时间为<span class="number">0.6s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发的效果是：鼠标悬停在一级菜单上，其内部的下拉菜单展开</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_block</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>); // 列表缩放变为<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    *</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_background</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">3px</span> <span class="built_in">rgb</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_area</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_block</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_text_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transition</span>: all <span class="number">0.6s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_block</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="attribute">background-color</span>: blue;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_block</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.the_dropdown_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;the_background&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;the_area&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">ul</span> class=&quot;the_list&quot;&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">ol</span> class=&quot;the_dropdown_list&quot;&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;/<span class="selector-tag">ol</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总而言之并没有用什么高级的技术，适配性也不怎么样，不过用来 完成大学里面的网页大作业应该是没问题了，该帖子主要以学习为主，不建议直接复制源码在工程中使用</p>
]]></content>
      <categories>
        <category>Web网页</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>教程</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集-模板</title>
    <url>/2022/04/12/Algorithm_Template/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>并查集&amp;带权并查集算法模板</p>
<span id="more"></span>
<h3 id="并查集-Distjoint-Set"><a href="#并查集-Distjoint-Set" class="headerlink" title="并查集 | Distjoint Set"></a>并查集 | Distjoint Set</h3><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>并查集(disjoint set)，英文意为与若干集合做交互，中文就更直观的表达了对集合做合并或查询的操作。<br>一般情况下需要其他信息配合并查集进行维护，也就是带权并查集。<br>有一些算法是实现也是基于并查集的思想，比如说最小生成树的kruskal和最近公共祖先的tarjan。  </p>
<h4 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h4><p>逻辑存储：使用树来表示集合的从属关系<br>物理存储：一个一维数组p[N],表示为某个节点的祖宗节点  </p>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//物理存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N;<span class="comment">//数据范围</span></span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//并查集数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = i; <span class="comment">//将每个节点的父节点初始化为自身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找 返回x的祖宗节点 + 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//递归实现路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并 a的祖宗节点成为b的祖宗节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//简单的合并一条语句即可，这里是为了带权并查集做准备</span></span><br><span class="line">    <span class="comment">//找到a和b的祖宗节点并备份</span></span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> bb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(aa != bb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//树的存储中为b的祖先节点指向a的祖先节点</span></span><br><span class="line">        p[<span class="built_in">find</span>(b)] = <span class="built_in">find</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带权并查集常见类型"><a href="#带权并查集常见类型" class="headerlink" title="带权并查集常见类型"></a>带权并查集常见类型</h4><p>这里特指需要更改merge或者find函数的类型</p>
<ul>
<li>更新集合的大小 -&gt; 绑定到根节点</li>
<li>更新到根节点的距离 -&gt; 绑定到每个节点</li>
</ul>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法简介</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-783-Div-2</title>
    <url>/2022/04/20/codeforces/Codeforces-Round-783-Div-2-A-C%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>div2#783赛后补题</p>
<span id="more"></span>
<h4 id="CodeForces-1668A-Direction-Change—原题链接"><a href="#CodeForces-1668A-Direction-Change—原题链接" class="headerlink" title="CodeForces 1668A. Direction Change—原题链接"></a>CodeForces 1668A. Direction Change—<a href="https://codeforces.com/contest/1668/problem/A">原题链接</a></h4><p>题目标签：数学 | 贪心  </p>
<blockquote>
<p>思路：<br>首先考虑不可行的情况，在一行中只能左右走的情况如果长边大于3那自然是不可行了<br>紧接着，对于每张图，可以看成一个大正方形拼上了一个较小的矩形，正方形的边长是原矩形的宽<br>这么考虑的原因是，从正方形的左上走到右下的唯一最短路就是沿着对角线走“台阶”，即step&#x3D;(n-1)^2<br>再考虑右侧的小矩形，走“日”一定可以走到对应的点，当然需要对奇偶性进行特判</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a, b); <span class="comment">//保证a能够作为矩形的宽</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b-a &gt;= <span class="number">2</span>) <span class="comment">//不成立情况的特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = b-a; <span class="comment">//小长方形的宽，判断其奇偶性</span></span><br><span class="line">        <span class="keyword">if</span>(d % <span class="number">2</span> == <span class="number">1</span>) cout &lt;&lt; (a<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>*(d<span class="number">-1</span>)+<span class="number">1</span> &lt;&lt; endl; <span class="comment">//奇数：最后一步是从左侧走进来的</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; (a<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>*d &lt;&lt; endl; <span class="comment">//偶数：最后一步是从上侧走进来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1668B-Social-Distance—原题链接"><a href="#CodeForces-1668B-Social-Distance—原题链接" class="headerlink" title="CodeForces 1668B. Social Distance—原题链接"></a>CodeForces 1668B. Social Distance—<a href="https://codeforces.com/contest/1668/problem/B">原题链接</a></h4><p>题目标签：贪心  </p>
<blockquote>
<p>思路：<br>若要满足所有人，消耗最多的一定是最麻烦的那个人，所以我们需要对数组排序然后对于最麻烦的人讨论<br>对于这个最麻烦的人，当他坐下后，已经不能再坐人的包括他的范围和他自己也就是a[max]*2+1<br>对于其他的人，坐在上一个人不能坐的边缘是是一定满足的，因为a[i]始终小于等于前者，因此只需要考虑他的一侧，也就是a[i]+1<br>最后一个人比较特殊，因为他的下一个就是最麻烦的人，因此他完全可以夹在两个人不能坐的边缘之间，也就是1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n, cmp); <span class="comment">//降序排序</span></span><br><span class="line">    LL num = a[<span class="number">0</span>] * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 处理消耗资源最多的那个人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) num += a[i] + <span class="number">1</span>; <span class="comment">// 中间的人只需要判断一侧即可</span></span><br><span class="line">    num++; <span class="comment">// 处理消耗资源最少的那个人</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= num) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;t);</span></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1668C-Make-it-Increasing—原题链接"><a href="#CodeForces-1668C-Make-it-Increasing—原题链接" class="headerlink" title="CodeForces 1668C. Make it Increasing—原题链接"></a>CodeForces 1668C. Make it Increasing—<a href="https://codeforces.com/contest/1668/problem/C">原题链接</a></h4><p>题目标签：模拟 | 贪心(?)  </p>
<blockquote>
<p>思路：<br>硬核模拟，我是没看出来哪里需要贪心，一开始贪心的思路也错了，一道卡了一个半小时+的c题QAQ<br>因为需要满足单调性的同时减少操作次数，因此保证其中一个数为0，至于哪一位为0就遍历一次<br>遍历到一位为0的时候，模拟一边更新的过程，因为模拟时每个元素值只会被访问一次，因此时间复杂度为O(n^2)<br><strong>值得注意的是</strong>，没有过的很重要的原因是long long的初始值开小了，学到了应该开1e18<br>但是改了这一点使用新构建数组的模拟还是没有过，迷惑+1，于是附上官方做法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1e18</span>; <span class="comment">// long long 的最大初始值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL num = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对于每次循环，需要保证pre刚刚满足由a[j]的倍数并且超过之前的per</span></span><br><span class="line">            <span class="comment">// 因此原先的per对a[j]取模，这个时候再加上一个a[j]就刚刚好超过per了</span></span><br><span class="line">            <span class="comment">// 于是per需要更新的大小就是单位量a[j]和相差量的差</span></span><br><span class="line">            pre += a[j] - pre%a[j];</span><br><span class="line">            num += pre / a[j]; <span class="comment">// 计算达到这个结果需要多少单位个a[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            pre += a[j] - pre%a[j]; <span class="comment">// 反方向来一遍，思路一样</span></span><br><span class="line">            num += pre / a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>codeforces</tag>
        <tag>赛后补题</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-776-Div-3</title>
    <url>/2022/04/20/codeforces/Codeforces-Round-776-Div-3-A-D%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>一定会补上剩下的题的，恩，一定会</p>
<span id="more"></span>
<h4 id="CodeForces-1650A-Deletions-of-Two-Adjacent-Letters—原题链接"><a href="#CodeForces-1650A-Deletions-of-Two-Adjacent-Letters—原题链接" class="headerlink" title="CodeForces 1650A. Deletions of Two Adjacent Letters—原题链接"></a>CodeForces 1650A. Deletions of Two Adjacent Letters—<a href="https://codeforces.com/contest/1650/problem/A">原题链接</a></h4><p>题目标签：思维题  </p>
<blockquote>
<p>思路：<br>除去只有一个字母的特殊情况，字符串中对出现的目标字母左右字符个数进行统计，只要满足一个字母的左右都是偶数，也就是能两个两个消掉就成立，否则不成立</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] != c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = s.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot;-&quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>((l &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (r &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650B-DIV-MOD—原题链接"><a href="#CodeForces-1650B-DIV-MOD—原题链接" class="headerlink" title="CodeForces 1650B. DIV + MOD—原题链接"></a>CodeForces 1650B. DIV + MOD—<a href="https://codeforces.com/contest/1650/problem/B">原题链接</a></h4><p>题目标签：数学  </p>
<blockquote>
<p>思路：<br>目标函数有两部分组成：<br>前半部分是单调递增的一次函数，后半部分是值域在[0, a-1]的周期函数，并且每个周期内递增<br>所以最大值有两个情况，要么是最右端，要么是周期函数中最靠右的峰值对应的点<br>注意定义域要在[l, r]之间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"><span class="type">int</span> l, r, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x / n) + (x % n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">f</span>(r);</span><br><span class="line">    <span class="type">int</span> t = r - r % n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">f</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= l) a = <span class="built_in">max</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650C-Weight-of-the-System-of-Nested-Segments—原题链接"><a href="#CodeForces-1650C-Weight-of-the-System-of-Nested-Segments—原题链接" class="headerlink" title="CodeForces 1650C. Weight of the System of Nested Segments—原题链接"></a>CodeForces 1650C. Weight of the System of Nested Segments—<a href="https://codeforces.com/contest/1650/problem/C">原题链接</a></h4><p>题目标签：贪心  </p>
<blockquote>
<p>思路：<br>反复排序求贪心即可，非常暴力的做法，总感觉会被hack…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id, dx, w, mark;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dx &lt; b.dx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node nodes[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> maxx = <span class="number">-1e9</span>, minn = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        nodes[i] = &#123;i, a, b, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(nodes+<span class="number">1</span>, nodes+<span class="number">1</span>+m, cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[i].mark = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nodes+<span class="number">1</span>, nodes+<span class="number">1</span>+m, cmp2);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = n;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=m;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nodes[i].mark &gt; <span class="number">2</span> * n) i++;</span><br><span class="line">        <span class="keyword">while</span>(nodes[j].mark &gt; <span class="number">2</span> * n) j--;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;nodes[i].id, nodes[j].id&#125;);</span><br><span class="line"></span><br><span class="line">        res = res + nodes[i].w + nodes[j].w;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=m; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; nodes[i].dx &lt;&lt; &quot; : &quot; &lt;&lt; nodes[i].w &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650D-Twist-the-Permutation—原题链接"><a href="#CodeForces-1650D-Twist-the-Permutation—原题链接" class="headerlink" title="CodeForces 1650D. Twist the Permutation—原题链接"></a>CodeForces 1650D. Twist the Permutation—<a href="https://codeforces.com/contest/1650/problem/D">原题链接</a></h4><p>题目标签：暴力 | 模拟  </p>
<blockquote>
<p>思路：<br>按照题目要求，恩模拟就完了，难点在于边界判断啊……<br>不得不说，虽然没有什么技术含量在里面，但是不看题解啃出来还是蛮有成就感</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> TIMES, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] == i)</span><br><span class="line">            &#123;</span><br><span class="line">                point = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(point == i) ans[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[i] = point;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = j - point + i;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= i+<span class="number">1</span>) t -= i;</span><br><span class="line">            b[t] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>codeforces</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
</search>

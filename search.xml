<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA基础 | 1、基本数据结构与流程控制</title>
    <url>/2022/03/22/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="第一部分-Java的基本数据结构与流程控制"><a href="#第一部分-Java的基本数据结构与流程控制" class="headerlink" title="第一部分 Java的基本数据结构与流程控制"></a>第一部分 Java的基本数据结构与流程控制</h3><p>本文是建立在拥有一定C&#x2F;C++基础上介绍的<strong>主观性极强的</strong>个人学习笔记，以个人感受和心得为主。</p>
<span id="more"></span>
<h4 id="I-最简单的Java应用程序"><a href="#I-最简单的Java应用程序" class="headerlink" title="I 最简单的Java应用程序"></a>I 最简单的Java应用程序</h4><p>众所周知，任何编程语言都是从一句Hello World开始的，所以…  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Hello world!</span><br></pre></td></tr></table></figure>
<p>简单分析： </p>
<ul>
<li>package表明这个java程序包含在MyJava这个包里面，包可以理解为类的容器</li>
<li>public称为访问修饰符，表示访问权限的级别，与C++基本类似  </li>
<li>class表明这是一个java的类，由此可见Java相较于C++更加依赖类与对象的使用，其中类的标识符约定俗成为首字母大写</li>
<li>println与C++中的printf或cout唯一不同的是，前者相当于输出后自动添加一个换行符，不需要的话同样有print方法可以使用  </li>
<li>java程序并不需要return 0，正常结束的java程序默认退出代码为0，若需要修改可以使用System.exit方法</li>
</ul>
<p>单从这一个Hello World来看，Java似乎并不是一个很简洁的语言（？），因为java十分注重类之间的包含和使用，因此在最开始会显得有些冗长，不过后续java的特点会慢慢展现出来，毕竟谁不喜欢int main（）呢<br>众所周知，读到这里你已经完全掌握了java并且可以找到不错的工作（不是），当然你也可以选择继续深入（<del>入土</del>）  </p>
<h4 id="II-注释"><a href="#II-注释" class="headerlink" title="II 注释"></a>II 注释</h4><p>java的注释继承了C++的注释方法，其中单行注释和多行注释完全一样，因此这里不做赘述，唯一的不同点在于java多了一项特殊的注释–文档注释  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 这是一份java的文档注释案例</span><br><span class="line">* @author Karuma</span><br><span class="line">* @version 1.0</span><br><span class="line">* @Update 2020/xx/xx</span><br><span class="line">* note：这家公司拖欠员工工资，赶紧跑路</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>值得一提的是，java可以根据文档注释的内容与关键字自动生成文档以及作者信息，这样即方便了项目管理也减轻了项目解释的工作  </p>
<h4 id="III-数据类型"><a href="#III-数据类型" class="headerlink" title="III 数据类型"></a>III 数据类型</h4><ul>
<li>整形：int、short、long、byte和C++在使用上几乎相同</li>
<li>浮点型：float、double和C++在使用上几乎相同</li>
<li>char：这里表示Unicode编码的字符单元的字符类型，可以简单理解为字符  </li>
<li>boolean：即C++的bool  </li>
<li>数组：与C++不同，java声明的方式为Templete[] name;此外，java的数组支持直接相互赋值（好耶）</li>
</ul>
<p>变量的声明与初始化、运算符类似于C++，不过常量的修饰符为final  </p>
<h4 id="IV-输入输出"><a href="#IV-输入输出" class="headerlink" title="IV 输入输出"></a>IV 输入输出</h4><p>对于java而言，标准输入流进行控制台输入需要以来Scanner类并与System.in关联，以下代码可以直观体现出Scanner的最基本的操作  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先的首先，使用Scanner类必须使用import引用java.util.Scanner</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//实例一个Scanner类的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请告诉我你的名字：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();<span class="comment">//将标准输入流的一行内容赋值给string类的对象name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你的名字是&quot;</span> + name);<span class="comment">//输出信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scanner对于数据的读入可以说相当方便，但是就安全性而言Console类更胜一筹，前者对于最基本的输入输出还是很便利的<br>Java的输出类似于C++中printf与cout的结合体，即支持简单的用+连接每个输出元素，又支持传统的占位符输出法  </p>
<h4 id="V-分支和循环"><a href="#V-分支和循环" class="headerlink" title="V 分支和循环"></a>V 分支和循环</h4><p>Java几乎完整延续了C++的流程控制语法，因此不多介绍</p>
<p>截止目前，Java和C++可以说是惊人的相似，我愿称之为C++++（C#：？）</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础 | 2、类与对象</title>
    <url>/2022/03/23/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="第二部分-类与对象"><a href="#第二部分-类与对象" class="headerlink" title="第二部分 类与对象"></a>第二部分 类与对象</h3><p>众所周知，“xxx是一门面向对象的编程语言”这句话折磨了许多初学面向对象的同学们（总之包括而我），因此，虽然这个说法非常不负责并且非常有问题，但是我需要直接了当的说：<strong>面向对象不就是结构体+函数吗</strong>（当然不是）  </p>
<span id="more"></span>
<h4 id="I-面向对象中java与C-的区别"><a href="#I-面向对象中java与C-的区别" class="headerlink" title="I 面向对象中java与C++的区别"></a>I 面向对象中java与C++的区别</h4><p>事实上，Java作为一个摒弃了指针的语言来讲，面向对象这部分与C++有着显著的不同，比如说在对象实例化的部分：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date birthday; // java:实例化一个Date对象，对象名称为birthday</span><br><span class="line">//然而在C++中的实际含义如下，尽管形式一样</span><br><span class="line">Date* birthday; // C++  </span><br></pre></td></tr></table></figure>
<p>并不只是面向对象这部分，Java中的变量并没有进行赋值，而是一个变量指向了一个数据，由此可见，与其说Java是摒弃了指针的语言，不如说是全程都在用（简化版的）指针的语言<del>（真香啊</del><br>在面向对象的程序中，应该尽量避免一个方法能够修改对象属性，甚至是直接访问对象属性，这都是不安全的，因此java类的设计通常有以下指定功能的方法：  </p>
<ul>
<li>构造器：最朴实无华的构造器，简单粗暴的new一个新对象，传统中的传统</li>
<li>静态工厂的构造器：不使用传统的构造器构造对象，而是使用这种特殊的方法（接口）构造一个新对象并且作为返回值可以赋值给对象变量  </li>
<li>更改器：看似是修改了对象的属性，其实是返回了一个属性不一样的新对象  </li>
<li>访问器：只访问对象而不修改对象的方法被称为访问器</li>
</ul>
<p>听起来似乎花里胡哨，但本质上他们都是一个类&#x2F;对象的方法罢了，只不过是人们根据他们的功能或特性起了一个（听起来很高端的）新名字，下面这个程序案例可以充分展示上述中三个新方法的使用：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里是静态工厂</span></span><br><span class="line">        <span class="comment">//使用静态工厂实例化一个表示现在日期的对象，对象名称为date</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过date对象，得到int型的月份和日期（这个月的第几天）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//date的日期更新为该月的第一天，也就是减去today再+1，赋值给date，再通过DayOfWeek类与方法返回星期数，并用value得到值</span></span><br><span class="line">        date = date.minusDays(today - <span class="number">1</span>); <span class="comment">// 这里是更改器</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> date.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue(); <span class="comment">// 这里是访问器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出表头，即格式部分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;value; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出日历主体，只要还在当月就继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(date.getMonthValue() == month)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出日期</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,date.getDayOfMonth());</span><br><span class="line">            <span class="comment">//判断是否为今天</span></span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfMonth() == today)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新date</span></span><br><span class="line">            date = date.plusDays(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Mon Tue Wed Thu Fri Sat Sun</span></span><br><span class="line"><span class="comment">      1   2   3   4   5   6 </span></span><br><span class="line"><span class="comment">  7   8   9  10  11  12  13 </span></span><br><span class="line"><span class="comment"> 14  15  16  17  18  19  20 </span></span><br><span class="line"><span class="comment"> 21  22  23* 24  25  26  27 </span></span><br><span class="line"><span class="comment"> 28  29  30  31 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用这些类，接口和方法，可以轻松处理日历的很麻烦的问题（尤其是不用考虑一大堆边界条件，因为大犇们已经提前造好轮子了），  </p>
<h4 id="II-用户自定义类"><a href="#II-用户自定义类" class="headerlink" title="II 用户自定义类"></a>II 用户自定义类</h4><p>与c++结构类似，其区别第一在于java的各种属性与方法有着很长的前缀，其二在于java在声明方法的时候定义方法。不过，前者只是将C++的访问权限展开罗列，后者将每个类定义在一个java文件中，所以综上所述java的自定义类和C++结构依然相似。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个最简单的java类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//field1</span></span><br><span class="line">    <span class="comment">//field2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//constructor1</span></span><br><span class="line">    <span class="comment">//constructor2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//method1</span></span><br><span class="line">    <span class="comment">//method2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止域值（对象的属性）出错或者随意修改，应该在针对一个属性拥有以下三个内容：</p>
<ul>
<li>一个私有的数据域  </li>
<li>一个公有的域访问器的方法  </li>
<li>一个公有的域更改器的方法</li>
</ul>
<p>这样有很多好处，一是内部实现不会影响其他代码，二是更改其可以执行错误检查<br>同时为了防止数据域的出错，在需要返回一个<strong>可变对象</strong>的时候需要进行克隆：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OutPut</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Date theDay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是不安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> theDay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) theday.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="III-静态域与静态方法"><a href="#III-静态域与静态方法" class="headerlink" title="III 静态域与静态方法"></a>III 静态域与静态方法</h4><p>静态前缀修饰符static即将变量的作用域设置为静态，这个修饰符可以作用于以下内容：  </p>
<ul>
<li>静态域：</li>
</ul>
<p>将成员属性设置为静态，即<strong>类中所有对象都公用一个的属性</strong>，在其他面向对象的语言中也会将其称为“类域”，对于静态域的使用有以下经典用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动设置雇员的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态常量</li>
</ul>
<p>即在常量中用static修饰，最经典的例子就是在Math类中的静态常量PI。<br>静态常量因为不能被修改，所以设置成公有也是没有问题的。  </p>
<ul>
<li>静态方法</li>
</ul>
<p>静态方法是一种不能对对象实施操作的方法，也就是没有this参数的方法，例如，Math终端pow方法，在使用时不许呀哦任何Math对象。<br>虽然静态方法不能访问实例域，但是可以访问静态域，也可以通过类名待用这个方法。  </p>
<ul>
<li>静态工厂</li>
</ul>
<p>类似LocalDate和NumberFormat的类使用静态工厂方法来构建对象，以NumberFormat为例，不使用构造器有以下两点原因：<br>一方面构造器的名字必须与类名相同，而实际希望将得到两种不同的名字<br>另一方面使用构造器时无法改变所构造的对象类型，而Factory方法将返回一个DecimalFormat类的对象，也就是NumberFormat的子类。  </p>
<ul>
<li>main方法</li>
</ul>
<p>调用静态方法不需要对象，同理。main方法也是一个静态方法，main函数不需要对任何对象进行操作。<br>事实上，程序启动的时候没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。<br>注： 每一个类都可以有一个main方法，常用于对类进行单元测试</p>
<ul>
<li>声明时赋值与初始化块</li>
</ul>
<p>虽然java可以使用常规的构造器初始化数据域，与C++不同，java可以在类声明属性的时候就对其进行初始化，除此之华还有“初始化块”这个第三种机制，只要构造类的对象，这些块就会被执行，对于静态域进行初始化的初始化块可以在花括号前单独加一个static前缀<br>类中调用构造器的顺序为：<br>数据域初始化为默认值 -&gt; 按照声明中出现的次序执行初始化块 -&gt; 若构造器中有其他构造器，先执行内部构造器，再执行外部构造器</p>
<h4 id="IV-包"><a href="#IV-包" class="headerlink" title="IV 包"></a>IV 包</h4><p>包是java中管理类的容器，一个类可以使用<strong>所属包中的所有类</strong>，以及<strong>其他包中的公有类</strong>，我们可以有两种方法访问其他包中的类：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种方法 显然比较繁琐</span><br><span class="line">java.time.LocalDate todaty = java.time.LocalDate.now();</span><br><span class="line"></span><br><span class="line">第二种方法，*代表导入这个包内的所有类，当然也可以只导入特定的类</span><br><span class="line">import java.until.*;</span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">除此之外，import语句不仅可以导入类，还可以用来导入静态方法和静态域（不过这样会很大程度降低代码的清晰度）  </span><br><span class="line">同理，设计好的类也需要放在包中。可以用以下语句实现：  </span><br><span class="line">```java</span><br><span class="line">package nameOfpackage;</span><br></pre></td></tr></table></figure>

<p>如果在包的目录中没有对应的类，也可以进行编译，但是最终程序无法正常运行，因此需要先将所有类文件移到正确的位置上。<br>除此之外，类文件也可以存储在JAR文件中，JAR文件可以理解为Java归档的ZIP格式组织文件，JDK提供了许多JAR文件的类库，同时JAR文件也方便其他第三方库的使用。  </p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第一周</title>
    <url>/2022/03/24/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第一周题解</p>
<span id="more"></span>
<h4 id="AcWing-3346-你知道你的ABC吗—原题链接"><a href="#AcWing-3346-你知道你的ABC吗—原题链接" class="headerlink" title="AcWing 3346. 你知道你的ABC吗—原题链接"></a>AcWing 3346. 你知道你的ABC吗—<a href="https://www.acwing.com/problem/content/3349/">原题链接</a></h4><p>题目标签：思维题 | 数学推理  </p>
<blockquote>
<p>思路：<br>由于7个数进行排序，第一个第二个数一定是a和b，第三个数有两种可能，要么是c，要么是a+b，如果是后者的话那么第四个数一定是c，也就是说进行一个小判断就行（某场cf的a题原题）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a+<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//判断第三个数是c还是a+b</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] + a[<span class="number">1</span>] == a[<span class="number">2</span>]) cout &lt;&lt; a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; a[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-3358-放养但没有完全放养—原题链接"><a href="#AcWing-3358-放养但没有完全放养—原题链接" class="headerlink" title="AcWing 3358. 放养但没有完全放养—原题链接"></a>AcWing 3358. 放养但没有完全放养—<a href="https://www.acwing.com/problem/content/3361/">原题链接</a></h4><p>题目标签：字符串 | 模拟 | 贪心(?)  </p>
<blockquote>
<p>思路1：<br>题目要求输出唱了多少遍，也就是一共需要听几遍才能按顺序听完目标字符串，那么：<br>Q：为什么需要再听一边<br>A：因为当前遍历到的字母之后不存在下一个字母，所以需要再听一遍<br>Q：什么时候需要再听一遍<br>A：当前字母出现的位置在之前字母的前边或者相同，因为如果在后边的话继续听下去是可以听到的<br>因此本题就是根据每个字母的位置进行比对</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">string s, s0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s0 &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(&#123;s0[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> flag = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        <span class="type">int</span> a = mp[flag], b = mp[c];</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= b) cnt++;</span><br><span class="line">        flag = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br>对上述的思路进行优化，字母顺序的比对直接遍历一遍就可以了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">26</span>];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++) p[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt;= p[s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span>]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3370-牛年—原题链接"><a href="#AcWing-3370-牛年—原题链接" class="headerlink" title="AcWing 3370. 牛年—原题链接"></a>AcWing 3370. 牛年—<a href="https://www.acwing.com/problem/content/3373/">原题链接</a></h4><p>题目标签：（自以为是的）DFS | 模拟  </p>
<blockquote>
<p>思路1：<br>建图DFS， <strong>虽然AC了但是是很绕弯子的思路</strong>拿到题的时候很自信的以为是图的深搜，结果敲了将近一个小时越来越觉得不对劲…虽说很别扭但是逻辑上可以说得通，并且很幸运的能够AC……坐等正解，看个乐子吧就当</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">1</span>, res;</span><br><span class="line"><span class="type">int</span> born[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> h[N * N], w[N * N], e[N * N], ne[N * N], idx;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp, day;</span><br><span class="line">string dayy[<span class="number">12</span>] = &#123;<span class="string">&quot;Ox&quot;</span>, <span class="string">&quot;Tiger&quot;</span>, <span class="string">&quot;Rabbit&quot;</span>, <span class="string">&quot;Dragon&quot;</span>, <span class="string">&quot;Snake&quot;</span>, <span class="string">&quot;Horse&quot;</span>, <span class="string">&quot;Goat&quot;</span>, <span class="string">&quot;Monkey&quot;</span>, <span class="string">&quot;Rooster&quot;</span>, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Pig&quot;</span>, <span class="string">&quot;Rat&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = u, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node == mp[<span class="string">&quot;Bessie&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        res = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[node]; i!=<span class="number">-1</span>; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j, sum + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        day.<span class="built_in">insert</span>(&#123;dayy[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    mp[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    born[<span class="number">0</span>] = mp[<span class="string">&quot;Ox&quot;</span>];</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++) cin &gt;&gt; str[j];</span><br><span class="line">        string name1 = str[<span class="number">0</span>], name2 = str[<span class="number">7</span>], year = str[<span class="number">4</span>], sta = str[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mp[name1] == <span class="number">0</span>) mp[name1] = cnt++;</span><br><span class="line">        <span class="keyword">if</span>(mp[name2] == <span class="number">0</span>) mp[name2] = cnt++;</span><br><span class="line"></span><br><span class="line">        born[mp[name1]] = day[year];</span><br><span class="line">        <span class="type">int</span> a = born[mp[name1]], b = born[mp[name2]], d;</span><br><span class="line">        <span class="keyword">if</span>(a == b) d = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - b + a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(mp[<span class="string">&quot;Elsie&quot;</span>], <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(res) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br><strong>因为题目中保证了后者的名字一定在前面出现过</strong>，所以其实只要简单模拟就可以了不需要做图的搜索。<br>另外关于距离部分，只需要做一次同余方程就可以减少很多代码量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; id = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Ox&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;Tiger&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Rabbit&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dragon&quot;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&quot;Snake&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;Horse&quot;</span>, <span class="number">5</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Goat&quot;</span>, <span class="number">6</span>&#125;, &#123;<span class="string">&quot;Monkey&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;Rooster&quot;</span>, <span class="number">8</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Dog&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;Pig&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;Rat&quot;</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    p[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">3</span>] == <span class="string">&quot;previous&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((x - y) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x - t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((y - x) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;\</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x + t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(p[<span class="string">&quot;Elsie&quot;</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3745-牛的学术圈-I—原题链接"><a href="#AcWing-3745-牛的学术圈-I—原题链接" class="headerlink" title="AcWing 3745. 牛的学术圈 I—原题链接"></a>AcWing 3745. 牛的学术圈 I—<a href="https://www.acwing.com/problem/content/3748/">原题链接</a></h4><p>题目标签：双指针 | 模拟 | 枚举  </p>
<blockquote>
<p>思路：<br><strong>我愿称之为本周最难的题</strong><br>当然难的部分在于对于既定答案的判断对错方法，尽管很抽象但是逻辑性还是很强的<br>首先我们知道可以最多改变l次，在排好序的基础上，我们希望能充分利用这l次+1的机会就必须在同一段上，并且加上这一段之后h可以有效的加一<br>顺着这个思路，假定我们遍历到了h，我们需要先定位到值为h-1的部分（i指针）。在定位到大于等于h-1的部分（j指针），此时区间被分为3部分：<br>1-j的部分：这部分的值<strong>恒大于等于h</strong>，也就是从j开始向左的所有数都不需要变化<br>j-i的部分：这部分的值<strong>都大于等于h-1</strong>，也就是从i开始到j（不包含j）的所有数是<strong>需要变化的数</strong><br>i-n的部分：这部分就算加了1也达不到h，也就是不需要变化的部分<br>如果我们假定的h成立，在将(j, i]的数加一之后，前h个数一定能保证大于h，也就是这个h成立了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>, q+<span class="number">1</span>+n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=n; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假定当h等于i成立时</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; q[j] &lt; i) j--; <span class="comment">//找到大于等于h的那个点（不需要改变的左端点）</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt;= i - <span class="number">1</span> &amp;&amp; i - j &lt;= k) res = i;<span class="comment">//保证q(j, i]中加一能大于等于i，并且这个区间的长度长度等于k</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AcWing-1459-奶牛体操—原题链接"><a href="#AcWing-1459-奶牛体操—原题链接" class="headerlink" title="AcWing 1459. 奶牛体操—原题链接"></a>AcWing 1459. 奶牛体操—<a href="https://www.acwing.com/problem/content/1461/">原题链接</a></h4><p>题目标签：枚举  </p>
<blockquote>
<p>思路：<br>满足题意的条件是，任意两个数，在所有排名中的先后次序都是一样的，其中一方指向另一方的方向不会变，因此可以开一个二位数组，横坐标指向纵坐标表示一次排名。<br>遍历结束后，如果只有一方指向另一方而没有反过来的方向，则成立。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                st[a[i]][a[j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]^ st[j][i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第二周</title>
    <url>/2022/03/26/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第二周题解</p>
<span id="more"></span>
<h4 id="AcWing-1442-单词处理器—原题链接"><a href="#AcWing-1442-单词处理器—原题链接" class="headerlink" title="AcWing 1442. 单词处理器—原题链接"></a>AcWing 1442. 单词处理器—<a href="https://www.acwing.com/problem/content/1444/">原题链接</a></h4><p>题目标签：字符串 | 模拟  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，派大星看了都会（向派大星道歉）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(now + s.<span class="built_in">size</span>() &lt;= k) now += s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            now = s.<span class="built_in">size</span>();</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-1671-三角形—原题链接"><a href="#AcWing-1671-三角形—原题链接" class="headerlink" title="AcWing 1671. 三角形—原题链接"></a>AcWing 1671. 三角形—<a href="https://www.acwing.com/problem/content/1673/">原题链接</a></h4><p>题目标签：暴力 | 枚举  </p>
<blockquote>
<p>思路：<br>恩枚举就完了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line">vector&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;q.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;q.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;q.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j || j==k || i==k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[i].first == q[j].first &amp;&amp; q[j].second == q[k].second)</span><br><span class="line">                        res = <span class="built_in">max</span>(res, <span class="built_in">abs</span>(q[j].first - q[k].first) * <span class="built_in">abs</span>(q[j].second - q[i].second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1659-社交距离-I—原题链接"><a href="#AcWing-1659-社交距离-I—原题链接" class="headerlink" title="AcWing 1659. 社交距离 I—原题链接"></a>AcWing 1659. 社交距离 I—<a href="https://www.acwing.com/problem/content/1661/">原题链接</a></h4><p>题目标签：分类讨论 | 模拟 | （也可以）二分  </p>
<blockquote>
<p>思路：<br>两头牛能摆放的情况，除了原先一头牛也没有之外，只有两种情况：<br>1、两头牛在同一去年内<br>2、两头牛分别在不同区间<br>算出这两种情况下的取值，取最大值的那个方案即为所需要的方案（输出时要和原先区间的最小值做比对并取最小值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) p[++cnt] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) cout &lt;&lt; n<span class="number">-1</span> &lt;&lt; endl; <span class="comment">//如果原先的序列里一头牛都没有</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xmin = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) xmin = <span class="built_in">min</span>(xmin, p[i+<span class="number">1</span>] - p[i]); <span class="comment">// 原先区间中距离的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两头牛在同一区间的方案</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">max</span>((p[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>, (n-p[cnt])/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) y = <span class="built_in">max</span>(y, (p[i+<span class="number">1</span>]-p[i])/<span class="number">3</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两头牛在不同区间的方案</span></span><br><span class="line">        <span class="type">int</span> y1 = p[<span class="number">1</span>]<span class="number">-1</span>, y2 = n-p[cnt];</span><br><span class="line">        <span class="keyword">if</span>(y1 &lt; y2) <span class="built_in">swap</span>(y1, y2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = (p[i+<span class="number">1</span>]-p[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= y1) y2 = y1, y1 = d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; y2) y2 = d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(xmin, <span class="built_in">max</span>(y, y2)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=cnt; i++) cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1714-混合牛奶—原题链接"><a href="#AcWing-1714-混合牛奶—原题链接" class="headerlink" title="AcWing 1714. 混合牛奶—原题链接"></a>AcWing 1714. 混合牛奶—<a href="https://www.acwing.com/problem/content/1716/">原题链接</a></h4><p>题目标签：模拟 | 找规律（做的时候没找到…）  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，这里面有规律可以找不过只需要操作100次因此恩模拟也没问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acow</span></span><br><span class="line">&#123;</span><br><span class="line">    PII a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acow cow;</span><br><span class="line">    cin &gt;&gt; cow.a.first &gt;&gt; cow.a.second &gt;&gt; cow.b.first &gt;&gt; cow.b.second &gt;&gt; cow.c.first &gt;&gt; cow.c.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1 -&gt; 2</span></span><br><span class="line">            <span class="keyword">if</span>(cow.a.second + cow.b.second &lt;= cow.b.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second += cow.a.second;</span><br><span class="line">                cow.a.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second -= cow.b.first -  cow.b.second;</span><br><span class="line">                cow.b.second = cow.b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2 -&gt; 3</span></span><br><span class="line">            <span class="keyword">if</span>(cow.b.second + cow.c.second &lt;= cow.c.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second += cow.b.second;</span><br><span class="line">                cow.b.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second -= cow.c.first - cow.c.second;</span><br><span class="line">                cow.c.second = cow.c.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//3 -&gt; 1</span></span><br><span class="line">            <span class="keyword">if</span>(cow.c.second + cow.a.second &lt;= cow.a.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second += cow.c.second;</span><br><span class="line">                cow.c.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second -= cow.a.first - cow.a.second;</span><br><span class="line">                cow.a.second = cow.a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cow.a.second &lt;&lt; endl &lt;&lt; cow.b.second &lt;&lt; endl &lt;&lt; cow.c.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1695-果壳游戏—原题链接"><a href="#AcWing-1695-果壳游戏—原题链接" class="headerlink" title="AcWing 1695. 果壳游戏—原题链接"></a>AcWing 1695. 果壳游戏—<a href="https://www.acwing.com/problem/content/1697/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>将三个杯子预定义好，按照题目的要求进行交换，点中的杯子就杯子内容+1，也就是说如果这个杯子里提前放了鹅卵石那他就能猜对，最后输出最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">swap</span>(p[a], p[b]);</span><br><span class="line">        ans[p[c]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(ans+<span class="number">1</span>, ans+<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础 | 1、首次登陆的简单指令</title>
    <url>/2022/03/23/Linux_Basic/Linux%E5%9F%BA%E7%A1%80-1-%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86%E7%9A%84%E7%AE%80%E5%8D%95%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>虽然但是，第一次面对控制台的操作系统，即没有知识储备，又害怕不小心弄错了什么，那就从最简单的一些系统指令入手8</p>
<span id="more"></span>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="I-指令格式"><a href="#I-指令格式" class="headerlink" title="I 指令格式"></a>I 指令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user@name ~]$ command [options] parameter1 parameter2 …</span><br></pre></td></tr></table></figure>
<p>绝大多数指令遵循以上框架，其详细说明如下：  </p>
<ul>
<li>@前的user指的是用户名，@后的name指的是计算机的名称，~符号表明文件的home目录  </li>
<li>$符号指的是“提示字符”，表示可以开始输入指令，其中root的提示字符为#  </li>
<li>command指的是指令名称或可执行文件</li>
<li>options指的是选项设定，实际使用时不加[]而是大部分用-作为前缀  </li>
<li>parameter指的是指令的参数，以<strong>不计个数的空格</strong>区分  </li>
<li>指令输入完毕后，回车键表示执行指令，指令太长时使用反斜杠\来跳脱回车符号</li>
</ul>
<p>注：Linux指令严格区分大小写，空格和回车是很重要的字符。  </p>
<p>尝试以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al ~</span><br></pre></td></tr></table></figure>
<p>效果为列出home目录下的所有隐藏档与相关文件的属性<br>关于指令的严格区分大小写，以下案例可以充分展示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date //显示日期和实现</span><br><span class="line">Date //找不到指令</span><br><span class="line">DATE //找不到指令</span><br></pre></td></tr></table></figure>
<p>综上所述，大小写在Linux中是有很大区别的。  </p>
<h4 id="II-语系"><a href="#II-语系" class="headerlink" title="II 语系"></a>II 语系</h4><p>由于Linux是支持多国语系的，如果系统默认设置下无法支持以中文编码输出数据，我们需要自行将支持语系改为英文，可以用到以下指令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale //显示目前支持的语系</span><br></pre></td></tr></table></figure>
<p>LANG 指语言语系的输出<br>LC_TIME 指时间方面的语系数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=en_US.utf8 //更改输出信息的语系</span><br><span class="line">export LC_ALL=en_US.utf8 //同步更新LC_ALL</span><br></pre></td></tr></table></figure>
<p>通过以上设置，就能够在本次登入中查看英文信息了  </p>
<h4 id="III-基础指令操作"><a href="#III-基础指令操作" class="headerlink" title="III 基础指令操作"></a>III 基础指令操作</h4><ul>
<li>显示日期的指令 date</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>不加任何参数的date指令可以输出当前时间，且格式为星期+月+日+时+分+秒+时区+年份<br>当然也可以输入带有参数的指令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +%Y/%m/%d //显示为 年/月/日</span><br><span class="line">date +%H:%M //显示为 时：分</span><br></pre></td></tr></table></figure>
<p>其中，第一行命令中的选项部分不一定以-开头，也可以由+开头  </p>
<ul>
<li><p>显示日历的指令 cal  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cal //直接输出本月的日历</span><br><span class="line">cal 2015 //输出2015年一整年的日历</span><br></pre></td></tr></table></figure>
<p>基本上cal这个命令可以接的语法为cal [month] [year]<br>当然如果输入了不存在的月份会出现对应的错误提示，对于Linux指令而言，指令反馈的错误是debug的一大关键信息  </p>
<h4 id="VI-重要的热键"><a href="#VI-重要的热键" class="headerlink" title="VI 重要的热键"></a>VI 重要的热键</h4></li>
<li><p>Tab 类似于在IDE中，在Linux命令行中Tab主要负责“补全”这一功能  </p>
<ol>
<li>在command部分中使用tab代表命令补齐，即输出所有满足已经输入部分文字为开头的指令  </li>
<li>在之后的部分使用tab代表文件&#x2F;参数&#x2F;选项补齐，具体依情况而定</li>
</ol>
</li>
<li><p>ctrl+c 终端目前程序，常用来跳出死循环  </p>
</li>
<li><p>ctrl+d 离开程序或输入结束，可以用来代替exit  </p>
</li>
<li><p>shift+pageup&#x2F;down 前后翻页</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础_3_类的继承</title>
    <url>/2022/03/28/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-3-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="第三部分-类的继承"><a href="#第三部分-类的继承" class="headerlink" title="第三部分 类的继承"></a>第三部分 类的继承</h3><p>对于面向对象的程序设计而言，“继承”这个特点可以很直观的反应某个程序的框架与逻辑，另一方面，继承这个特点同样是程序设计语言中<strong>逐渐精简</strong>的特点的展现。  </p>
<span id="more"></span>
<h4 id="I-类-amp-超类-amp-子类"><a href="#I-类-amp-超类-amp-子类" class="headerlink" title="I 类&amp;超类&amp;子类"></a>I 类&amp;超类&amp;子类</h4><p>假如我们要设计很相似的两个类，这两个类的大部分属性和方法都一样，只是其中一个类相比于另一个多了几个属性和方法。此时如果将两个类同时写出来很明显存在代码重复的问题，这在程序设计中是很不建议的，因此可以用到继承这一概念。<br>以经理Manager与普通员工Employee举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新增的域和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字extends类似于C++中的冒号，表明正在基于已经存在的一个类（超类，基类。父类）来创造一个新的类（子类，派生类，孩子类）。<br>其中，子类不能直接访问父类的私有域，只有通过父类的公共接口才能访问。如果在方法中覆盖父类的方法并调用这个方法（我们希望调用父类的功能），并且由于子类也有这样的方法，就会无限调用下去直到程序崩溃，为此，我们可以使用关键字super来覆盖已有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决覆盖的问题，C++中需要写出整个父类的名称，而Java中super关键字直观的告诉我们，这个地方使用的是父类的方法，因此不会造成死循环。在子类中我们可以增加域，方法或者覆盖超类的方法，然而绝对不能删除继承的任何域和方法。<br>this作为隐式参数这个关键字有两个用途，一是可以被引用，二是调用该类的其他构造器，同样的super也作为一个隐式参数不光可以被引用，也可以调用父类的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//super必须放在构造器的最前面</span></span><br><span class="line">        <span class="built_in">super</span>(name, salary, year, month, day);</span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用for-each循环的时候，在调用父类和子类同名不同功能的方法时，虚拟机会自己判断对象是父类还是子类再进行相应的调用。<br>一个对象变量可以指示多种实际类型的现象成为<strong>多态</strong>，在与运行时能够自动选择调用的方法的现象称为<strong>动态绑定</strong>。如果是private，static，final的方法被称为<strong>静态绑定</strong>。<br>在Java中，对象变量是多态的，一个Employee对象即可以引用一个Employee对象，也可以引用Employee子类的对象，反之则不可以，并且调用方法的时候遵循哪个类的对象才可以调用哪个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关于类的强制类型转换，只能自顶向下进行转换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Employee类的对象变量引用boss，可以运行</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">staff</span> <span class="operator">=</span> boss;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Manager类的对象变量引用worker，不能运行</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">errorBoss</span> <span class="operator">=</span> worker;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以用boss调用专属于Manager的方法，而staff不可以</span></span><br><span class="line">        <span class="comment">//即使他们引用的是同一个对象</span></span><br><span class="line">        boss.setBonus(<span class="number">5000</span>); <span class="comment">// OK</span></span><br><span class="line">        staff.setBonus(<span class="number">5000</span>); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不允许被扩展的类被称为final类，在定义类的时候添加final修饰符即可，同理，不允许被覆盖的方法被称为final方法。<br>如果两个相似的子类需要输出一串简介信息，但是内容相差比较大，对于父类来说不太容易定义这个看似关联实则区别比较大的方法，这里就可以用到<strong>抽象类</strong>这个概念：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父类中创建抽象方法后，在子类中重载即可。</span></span><br><span class="line">    <span class="comment">// 类比于C++中的：virtual string getDescription() = 0;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自下而上的继承中，位于上层的类更通用的同时也更抽象，因此抽象abstract这个关键字就很好的解决了这个问题.<br>对于java中的访问，有以下四种情况：  </p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">子类</th>
<th align="center">所有类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h4 id="II-所有类的父类-Object"><a href="#II-所有类的父类-Object" class="headerlink" title="II 所有类的父类 - Object"></a>II 所有类的父类 - Object</h4><p>在Java中，除了基本类型（数值，字符，布尔值）以外，所有的变量都是对象变量，包括我们常见的数组（包括对象数组和普通数组）都是扩展了Object类的对象。<br>Object类是所有类的父类，我们定义类的时候虽然没有写出”extends Object“，但实际上却有这个含义。<br>以下将介绍部分Object类提供的方法，关于处理线程的方法将在后续介绍：  </p>
<ul>
<li>equals：用于比较两个类是否相等，默认的比较方式是检查是否具有相同的引用，确认两个对象是否相等需要很多逻辑上的判断且子类需要先调用父类的equals。  </li>
<li>hashCode：返回对象的散列码，可以理解成对象的ID，默认的散列码为对象的存储地址。hashcode自定义散列码时要保证相同对象有相同散列码，也可以用静态方法Object.hash(需要比较的参数)来生成。  </li>
<li>toString：返回对象的字符串，默认是类的名字+地址，自定义这个方法是一种非常有用的调试工具，标准类库中有很多这样的方法重载  <h4 id="III-泛型数组列表-ArrayList-与包装器"><a href="#III-泛型数组列表-ArrayList-与包装器" class="headerlink" title="III 泛型数组列表(ArrayList)与包装器"></a>III 泛型数组列表(ArrayList)与包装器</h4>对于类似C++中的vector可变数组的操作，java中提供了ArrayList类，它是一个采用类型参数的泛型类，使用时需要用尖括号来定义对象的类型：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类比于C++的模板</span><br><span class="line">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>
ArrayList类和C++的vector极为相似，但是需要注意的是，java中没有运算符的重载，意味着不能通过[]来访问元素，并且访问和修改元素的操作需要get和set方法来实现。<br>除此之外，虽说在Java这个极度面向对象的设计语言中，基础数据类型不作为对象存在，不过我们可以用他们来制造属于他们的对象，也就是包装器，具体类型的包装器对应其英文拼写：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//包装器可以实现自动打包(装箱),等价于list.add(Integer.valueOf(3));</span><br><span class="line">list.add(3);</span><br><span class="line">//也可以实现自动拆箱，等价于list.get(i).intValue();</span><br><span class="line">int n = list.get(i);</span><br></pre></td></tr></table></figure>
除此之外，包装器还提供了许多实用的静态方法，如Integer类中的ParseInt(String)可以将字符串转换为整数并返回。  <h4 id="IV-可变参数的方法"><a href="#IV-可变参数的方法" class="headerlink" title="IV 可变参数的方法"></a>IV 可变参数的方法</h4>顾名思义，即参数不固定的例子，printf就是一个很好的例子:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的...是实际代码的一部分，表明可以接受任意数量的对象</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object...args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上，printf接收到的两个参数分别为fmt和Object[]数组，也就是说，对于使用者而言，Object…参数类型和Object[]完全一样。  <h4 id="V-继承的设计技巧"><a href="#V-继承的设计技巧" class="headerlink" title="V 继承的设计技巧"></a>V 继承的设计技巧</h4></li>
<li>将公共操作和域放在父类中  </li>
<li>非特殊情况下，不要使用protected</li>
<li>使用继承实现”is-a”的关系，构建成一棵树</li>
<li>除非所有的继承方法都有意义，否则不要使用继承</li>
<li>在重载方法的时候，不要改变预期的行为</li>
<li>使用多态，而非一连串的分支</li>
<li>不要过多使用反射库</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>

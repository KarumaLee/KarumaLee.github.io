<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>置顶 | Karuma算法垃圾桶</title>
    <url>/2022/04/20/topList/</url>
    <content><![CDATA[<p>记录一些易错点和刷题日志</p>
<span id="more"></span>
<p>以下都是易错点:</p>
<ul>
<li>对最小值初始化的时候 long long 需要开到18次幂以上的规模</li>
</ul>
<hr>
<p>以下是算法日志:<br>2022-5<br>1</p>
]]></content>
  </entry>
  <entry>
    <title>并查集-模板</title>
    <url>/2022/04/12/Algorithm_Template/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>并查集&amp;带权并查集算法模板</p>
<span id="more"></span>
<h3 id="并查集-Distjoint-Set"><a href="#并查集-Distjoint-Set" class="headerlink" title="并查集 | Distjoint Set"></a>并查集 | Distjoint Set</h3><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>并查集(disjoint set)，英文意为与若干集合做交互，中文就更直观的表达了对集合做合并或查询的操作。<br>一般情况下需要其他信息配合并查集进行维护，也就是带权并查集。<br>有一些算法是实现也是基于并查集的思想，比如说最小生成树的kruskal和最近公共祖先的tarjan。  </p>
<h4 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h4><p>逻辑存储：使用树来表示集合的从属关系<br>物理存储：一个一维数组p[N],表示为某个节点的祖宗节点  </p>
<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//物理存储</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N;<span class="comment">//数据范围</span></span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//并查集数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) p[i] = i; <span class="comment">//将每个节点的父节点初始化为自身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找 返回x的祖宗节点 + 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//递归实现路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并 a的祖宗节点成为b的祖宗节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//简单的合并一条语句即可，这里是为了带权并查集做准备</span></span><br><span class="line">    <span class="comment">//找到a和b的祖宗节点并备份</span></span><br><span class="line">    <span class="type">int</span> aa = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> bb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(aa != bb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//树的存储中为b的祖先节点指向a的祖先节点</span></span><br><span class="line">        p[<span class="built_in">find</span>(b)] = <span class="built_in">find</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带权并查集常见类型"><a href="#带权并查集常见类型" class="headerlink" title="带权并查集常见类型"></a>带权并查集常见类型</h4><p>这里特指需要更改merge或者find函数的类型</p>
<ul>
<li>更新集合的大小 -&gt; 绑定到根节点</li>
<li>更新到根节点的距离 -&gt; 绑定到每个节点</li>
</ul>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法简介</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第一周</title>
    <url>/2022/03/24/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-1-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第一周题解</p>
<span id="more"></span>
<h4 id="AcWing-3346-你知道你的ABC吗—原题链接"><a href="#AcWing-3346-你知道你的ABC吗—原题链接" class="headerlink" title="AcWing 3346. 你知道你的ABC吗—原题链接"></a>AcWing 3346. 你知道你的ABC吗—<a href="https://www.acwing.com/problem/content/3349/">原题链接</a></h4><p>题目标签：思维题 | 数学推理  </p>
<blockquote>
<p>思路：<br>由于7个数进行排序，第一个第二个数一定是a和b，第三个数有两种可能，要么是c，要么是a+b，如果是后者的话那么第四个数一定是c，也就是说进行一个小判断就行（某场cf的a题原题）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a+<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//判断第三个数是c还是a+b</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>] + a[<span class="number">1</span>] == a[<span class="number">2</span>]) cout &lt;&lt; a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; a[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-3358-放养但没有完全放养—原题链接"><a href="#AcWing-3358-放养但没有完全放养—原题链接" class="headerlink" title="AcWing 3358. 放养但没有完全放养—原题链接"></a>AcWing 3358. 放养但没有完全放养—<a href="https://www.acwing.com/problem/content/3361/">原题链接</a></h4><p>题目标签：字符串 | 模拟 | 贪心(?)  </p>
<blockquote>
<p>思路1：<br>题目要求输出唱了多少遍，也就是一共需要听几遍才能按顺序听完目标字符串，那么：<br>Q：为什么需要再听一边<br>A：因为当前遍历到的字母之后不存在下一个字母，所以需要再听一遍<br>Q：什么时候需要再听一遍<br>A：当前字母出现的位置在之前字母的前边或者相同，因为如果在后边的话继续听下去是可以听到的<br>因此本题就是根据每个字母的位置进行比对</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">string s, s0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s0 &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp.<span class="built_in">insert</span>(&#123;s0[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> flag = s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        <span class="type">int</span> a = mp[flag], b = mp[c];</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= b) cnt++;</span><br><span class="line">        flag = c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br>对上述的思路进行优化，字母顺序的比对直接遍历一遍就可以了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">26</span>];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++) p[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt;= p[s[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span>]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3370-牛年—原题链接"><a href="#AcWing-3370-牛年—原题链接" class="headerlink" title="AcWing 3370. 牛年—原题链接"></a>AcWing 3370. 牛年—<a href="https://www.acwing.com/problem/content/3373/">原题链接</a></h4><p>题目标签：（自以为是的）DFS | 模拟  </p>
<blockquote>
<p>思路1：<br>建图DFS， <strong>虽然AC了但是是很绕弯子的思路</strong>拿到题的时候很自信的以为是图的深搜，结果敲了将近一个小时越来越觉得不对劲…虽说很别扭但是逻辑上可以说得通，并且很幸运的能够AC……坐等正解，看个乐子吧就当</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">1</span>, res;</span><br><span class="line"><span class="type">int</span> born[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> h[N * N], w[N * N], e[N * N], ne[N * N], idx;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp, day;</span><br><span class="line">string dayy[<span class="number">12</span>] = &#123;<span class="string">&quot;Ox&quot;</span>, <span class="string">&quot;Tiger&quot;</span>, <span class="string">&quot;Rabbit&quot;</span>, <span class="string">&quot;Dragon&quot;</span>, <span class="string">&quot;Snake&quot;</span>, <span class="string">&quot;Horse&quot;</span>, <span class="string">&quot;Goat&quot;</span>, <span class="string">&quot;Monkey&quot;</span>, <span class="string">&quot;Rooster&quot;</span>, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Pig&quot;</span>, <span class="string">&quot;Rat&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = u, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node == mp[<span class="string">&quot;Bessie&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        res = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[node]; i!=<span class="number">-1</span>; i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(st[j] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j, sum + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        day.<span class="built_in">insert</span>(&#123;dayy[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    mp[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    born[<span class="number">0</span>] = mp[<span class="string">&quot;Ox&quot;</span>];</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;,&amp;n);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++) cin &gt;&gt; str[j];</span><br><span class="line">        string name1 = str[<span class="number">0</span>], name2 = str[<span class="number">7</span>], year = str[<span class="number">4</span>], sta = str[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mp[name1] == <span class="number">0</span>) mp[name1] = cnt++;</span><br><span class="line">        <span class="keyword">if</span>(mp[name2] == <span class="number">0</span>) mp[name2] = cnt++;</span><br><span class="line"></span><br><span class="line">        born[mp[name1]] = day[year];</span><br><span class="line">        <span class="type">int</span> a = born[mp[name1]], b = born[mp[name2]], d;</span><br><span class="line">        <span class="keyword">if</span>(a == b) d = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b &amp;&amp; sta[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = <span class="number">12</span> - b + a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sta[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(mp[name2], mp[name1], d);</span><br><span class="line">            <span class="built_in">add</span>(mp[name1], mp[name2], <span class="number">-1</span> * d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(mp[<span class="string">&quot;Elsie&quot;</span>], <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(res) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（标答）思路2：<br><strong>因为题目中保证了后者的名字一定在前面出现过</strong>，所以其实只要简单模拟就可以了不需要做图的搜索。<br>另外关于距离部分，只需要做一次同余方程就可以减少很多代码量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; id = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Ox&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;Tiger&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;Rabbit&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dragon&quot;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&quot;Snake&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;Horse&quot;</span>, <span class="number">5</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Goat&quot;</span>, <span class="number">6</span>&#125;, &#123;<span class="string">&quot;Monkey&quot;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&quot;Rooster&quot;</span>, <span class="number">8</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;Dog&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;Pig&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;Rat&quot;</span>, <span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    p[<span class="string">&quot;Bessie&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">3</span>] == <span class="string">&quot;previous&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((x - y) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x - t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = p[s[<span class="number">7</span>]], y = id[s[<span class="number">4</span>]];</span><br><span class="line">            <span class="type">int</span> t = ((y - x) % <span class="number">12</span> + <span class="number">12</span>) % <span class="number">12</span>;\</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>) t = <span class="number">12</span>;</span><br><span class="line">            p[s[<span class="number">0</span>]] = x + t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(p[<span class="string">&quot;Elsie&quot;</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-3745-牛的学术圈-I—原题链接"><a href="#AcWing-3745-牛的学术圈-I—原题链接" class="headerlink" title="AcWing 3745. 牛的学术圈 I—原题链接"></a>AcWing 3745. 牛的学术圈 I—<a href="https://www.acwing.com/problem/content/3748/">原题链接</a></h4><p>题目标签：双指针 | 模拟 | 枚举  </p>
<blockquote>
<p>思路：<br><strong>我愿称之为本周最难的题</strong><br>当然难的部分在于对于既定答案的判断对错方法，尽管很抽象但是逻辑性还是很强的<br>首先我们知道可以最多改变l次，在排好序的基础上，我们希望能充分利用这l次+1的机会就必须在同一段上，并且加上这一段之后h可以有效的加一<br>顺着这个思路，假定我们遍历到了h，我们需要先定位到值为h-1的部分（i指针）。在定位到大于等于h-1的部分（j指针），此时区间被分为3部分：<br>1-j的部分：这部分的值<strong>恒大于等于h</strong>，也就是从j开始向左的所有数都不需要变化<br>j-i的部分：这部分的值<strong>都大于等于h-1</strong>，也就是从i开始到j（不包含j）的所有数是<strong>需要变化的数</strong><br>i-n的部分：这部分就算加了1也达不到h，也就是不需要变化的部分<br>如果我们假定的h成立，在将(j, i]的数加一之后，前h个数一定能保证大于h，也就是这个h成立了  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>, q+<span class="number">1</span>+n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=n; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假定当h等于i成立时</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; q[j] &lt; i) j--; <span class="comment">//找到大于等于h的那个点（不需要改变的左端点）</span></span><br><span class="line">        <span class="keyword">if</span>(q[i] &gt;= i - <span class="number">1</span> &amp;&amp; i - j &lt;= k) res = i;<span class="comment">//保证q(j, i]中加一能大于等于i，并且这个区间的长度长度等于k</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AcWing-1459-奶牛体操—原题链接"><a href="#AcWing-1459-奶牛体操—原题链接" class="headerlink" title="AcWing 1459. 奶牛体操—原题链接"></a>AcWing 1459. 奶牛体操—<a href="https://www.acwing.com/problem/content/1461/">原题链接</a></h4><p>题目标签：枚举  </p>
<blockquote>
<p>思路：<br>满足题意的条件是，任意两个数，在所有排名中的先后次序都是一样的，其中一方指向另一方的方向不会变，因此可以开一个二位数组，横坐标指向纵坐标表示一次排名。<br>遍历结束后，如果只有一方指向另一方而没有反过来的方向，则成立。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                st[a[i]][a[j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]^ st[j][i]) res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题-2-第四周</title>
    <url>/2022/04/11/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第二周题解</p>
<span id="more"></span>
<h4 id="AcWing-1812-方形牧场—原题链接"><a href="#AcWing-1812-方形牧场—原题链接" class="headerlink" title="AcWing 1812. 方形牧场—原题链接"></a>AcWing 1812. 方形牧场—<a href="https://www.acwing.com/problem/content/1814/">原题链接</a></h4><p>题目标签：枚举  </p>
<blockquote>
<p>思路：<br>暴力枚举即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    x1 = y1 = <span class="number">15</span>, x2 = y2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a1, b1, c1, d1, a2, b2, c2, d2;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; d1 &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; c2 &gt;&gt; d2;</span><br><span class="line">    x1 = <span class="built_in">min</span>(x1, <span class="built_in">min</span>(a1, <span class="built_in">min</span>(c1, <span class="built_in">min</span>(a2, c2))));</span><br><span class="line">    y1 = <span class="built_in">min</span>(y1, <span class="built_in">min</span>(b1, <span class="built_in">min</span>(d1, <span class="built_in">min</span>(b2, d2))));</span><br><span class="line">    x2 = <span class="built_in">max</span>(x2, <span class="built_in">max</span>(a1, <span class="built_in">max</span>(c1, <span class="built_in">max</span>(a2, c2))));</span><br><span class="line">    y2 = <span class="built_in">max</span>(y1, <span class="built_in">max</span>(b1, <span class="built_in">max</span>(d1, <span class="built_in">max</span>(b2, d2))));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">max</span>(<span class="built_in">abs</span>(x2 - x1), <span class="built_in">abs</span>(y2 - y1));</span><br><span class="line">    cout &lt;&lt; n * n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1800-不做最后一个！—原题链接"><a href="#AcWing-1800-不做最后一个！—原题链接" class="headerlink" title="AcWing 1800. 不做最后一个！—原题链接"></a>AcWing 1800. 不做最后一个！—<a href="https://www.acwing.com/problem/content/1802/">原题链接</a></h4><p>题目标签：  </p>
<blockquote>
<p>思路：<br>n不大于100，因此直接暴力，非常滴暴力且不聪明</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;daaaaaaa</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; mp = &#123;&#123;<span class="string">&quot;Bessie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Elsie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Daisy&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Gertie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Annabelle&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Maggie&quot;</span>, <span class="number">0</span>&#125;,&#123;<span class="string">&quot;Henrietta&quot;</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line">        mp[s] += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; v1;</span><br><span class="line">    <span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, t.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.second != minn) v1.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v1.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; v2;</span><br><span class="line">    minn = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn = <span class="built_in">min</span>(minn, v1[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = v1[i];</span><br><span class="line">        <span class="keyword">if</span>(t.second == minn) v2.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v2.<span class="built_in">size</span>() == <span class="number">1</span>) cout &lt;&lt; v2[<span class="number">0</span>].first &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Tie&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1788-牛为什么过马路—原题链接"><a href="#AcWing-1788-牛为什么过马路—原题链接" class="headerlink" title="AcWing 1788. 牛为什么过马路—原题链接"></a>AcWing 1788. 牛为什么过马路—<a href="https://www.acwing.com/problem/content/description/1790/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>直接模拟</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(p[a] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[a] != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1775-丢失的牛—原题链接"><a href="#AcWing-1775-丢失的牛—原题链接" class="headerlink" title="AcWing 1775. 丢失的牛—原题链接"></a>AcWing 1775. 丢失的牛—<a href="https://www.acwing.com/problem/content/1777/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：直接模拟就行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dist, now, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">0</span>, step = <span class="number">1</span>, last = x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> next = x + step;</span><br><span class="line">        <span class="keyword">if</span>((y &gt;= last &amp;&amp; y &lt;= next) || (y &gt;= next &amp;&amp; y &lt;= last))</span><br><span class="line">        &#123;</span><br><span class="line">            dist += <span class="built_in">abs</span>(last - y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dist += <span class="built_in">abs</span>(last - next);</span><br><span class="line">        step *= (<span class="number">-2</span>);</span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dist &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1866-围栏刷漆—原题链接"><a href="#AcWing-1866-围栏刷漆—原题链接" class="headerlink" title="AcWing 1866. 围栏刷漆—原题链接"></a>AcWing 1866. 围栏刷漆—<a href="https://www.acwing.com/problem/content/description/1868/">原题链接</a></h4><p>题目标签：集合  </p>
<blockquote>
<p>思路：<br>虽然可以暴力模拟，但是集合才应该是本题的考点，两个线段集合在确定头部关系的情况下只有包含，重合，不重合三种情况，分类讨论即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a, c);</span><br><span class="line">        <span class="built_in">swap</span>(b, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt; d)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b + d - a - c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; b - a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d - a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1854-晋升计数—原题链接"><a href="#AcWing-1854-晋升计数—原题链接" class="headerlink" title="AcWing 1854. 晋升计数—原题链接"></a>AcWing 1854. 晋升计数—<a href="https://www.acwing.com/problem/content/1856/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>模拟 × 阅读理解 √， 并且使用n是为了兼容比赛组别不一定为4的情况</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    res[n] = b[n] - a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">2</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = res[i+<span class="number">1</span>] + b[i] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础 | 1、基本数据结构与流程控制</title>
    <url>/2022/03/22/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h3 id="第一部分-Java的基本数据结构与流程控制"><a href="#第一部分-Java的基本数据结构与流程控制" class="headerlink" title="第一部分 Java的基本数据结构与流程控制"></a>第一部分 Java的基本数据结构与流程控制</h3><p>本文是建立在拥有一定C&#x2F;C++基础上介绍的<strong>主观性极强的</strong>个人学习笔记，以个人感受和心得为主。</p>
<span id="more"></span>
<h4 id="I-最简单的Java应用程序"><a href="#I-最简单的Java应用程序" class="headerlink" title="I 最简单的Java应用程序"></a>I 最简单的Java应用程序</h4><p>众所周知，任何编程语言都是从一句Hello World开始的，所以…  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Hello world!</span><br></pre></td></tr></table></figure>
<p>简单分析： </p>
<ul>
<li>package表明这个java程序包含在MyJava这个包里面，包可以理解为类的容器</li>
<li>public称为访问修饰符，表示访问权限的级别，与C++基本类似  </li>
<li>class表明这是一个java的类，由此可见Java相较于C++更加依赖类与对象的使用，其中类的标识符约定俗成为首字母大写</li>
<li>println与C++中的printf或cout唯一不同的是，前者相当于输出后自动添加一个换行符，不需要的话同样有print方法可以使用  </li>
<li>java程序并不需要return 0，正常结束的java程序默认退出代码为0，若需要修改可以使用System.exit方法</li>
</ul>
<p>单从这一个Hello World来看，Java似乎并不是一个很简洁的语言（？），因为java十分注重类之间的包含和使用，因此在最开始会显得有些冗长，不过后续java的特点会慢慢展现出来，毕竟谁不喜欢int main（）呢<br>众所周知，读到这里你已经完全掌握了java并且可以找到不错的工作（不是），当然你也可以选择继续深入（<del>入土</del>）  </p>
<h4 id="II-注释"><a href="#II-注释" class="headerlink" title="II 注释"></a>II 注释</h4><p>java的注释继承了C++的注释方法，其中单行注释和多行注释完全一样，因此这里不做赘述，唯一的不同点在于java多了一项特殊的注释–文档注释  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 这是一份java的文档注释案例</span><br><span class="line">* @author Karuma</span><br><span class="line">* @version 1.0</span><br><span class="line">* @Update 2020/xx/xx</span><br><span class="line">* note：这家公司拖欠员工工资，赶紧跑路</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>值得一提的是，java可以根据文档注释的内容与关键字自动生成文档以及作者信息，这样即方便了项目管理也减轻了项目解释的工作  </p>
<h4 id="III-数据类型"><a href="#III-数据类型" class="headerlink" title="III 数据类型"></a>III 数据类型</h4><ul>
<li>整形：int、short、long、byte和C++在使用上几乎相同</li>
<li>浮点型：float、double和C++在使用上几乎相同</li>
<li>char：这里表示Unicode编码的字符单元的字符类型，可以简单理解为字符  </li>
<li>boolean：即C++的bool  </li>
<li>数组：与C++不同，java声明的方式为Templete[] name;此外，java的数组支持直接相互赋值（好耶）</li>
</ul>
<p>变量的声明与初始化、运算符类似于C++，不过常量的修饰符为final  </p>
<h4 id="IV-输入输出"><a href="#IV-输入输出" class="headerlink" title="IV 输入输出"></a>IV 输入输出</h4><p>对于java而言，标准输入流进行控制台输入需要以来Scanner类并与System.in关联，以下代码可以直观体现出Scanner的最基本的操作  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先的首先，使用Scanner类必须使用import引用java.util.Scanner</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//实例一个Scanner类的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请告诉我你的名字：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();<span class="comment">//将标准输入流的一行内容赋值给string类的对象name</span></span><br><span class="line">        System.out.println(<span class="string">&quot;你的名字是&quot;</span> + name);<span class="comment">//输出信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scanner对于数据的读入可以说相当方便，但是就安全性而言Console类更胜一筹，前者对于最基本的输入输出还是很便利的<br>Java的输出类似于C++中printf与cout的结合体，即支持简单的用+连接每个输出元素，又支持传统的占位符输出法  </p>
<h4 id="V-分支和循环"><a href="#V-分支和循环" class="headerlink" title="V 分支和循环"></a>V 分支和循环</h4><p>Java几乎完整延续了C++的流程控制语法，因此不多介绍</p>
<p>截止目前，Java和C++可以说是惊人的相似，我愿称之为C++++（C#：？）</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础_3_类的继承</title>
    <url>/2022/03/28/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-3-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h3 id="第三部分-类的继承"><a href="#第三部分-类的继承" class="headerlink" title="第三部分 类的继承"></a>第三部分 类的继承</h3><p>对于面向对象的程序设计而言，“继承”这个特点可以很直观的反应某个程序的框架与逻辑，另一方面，继承这个特点同样是程序设计语言中<strong>逐渐精简</strong>的特点的展现。  </p>
<span id="more"></span>
<h4 id="I-类-amp-超类-amp-子类"><a href="#I-类-amp-超类-amp-子类" class="headerlink" title="I 类&amp;超类&amp;子类"></a>I 类&amp;超类&amp;子类</h4><p>假如我们要设计很相似的两个类，这两个类的大部分属性和方法都一样，只是其中一个类相比于另一个多了几个属性和方法。此时如果将两个类同时写出来很明显存在代码重复的问题，这在程序设计中是很不建议的，因此可以用到继承这一概念。<br>以经理Manager与普通员工Employee举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新增的域和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字extends类似于C++中的冒号，表明正在基于已经存在的一个类（超类，基类。父类）来创造一个新的类（子类，派生类，孩子类）。<br>其中，子类不能直接访问父类的私有域，只有通过父类的公共接口才能访问。如果在方法中覆盖父类的方法并调用这个方法（我们希望调用父类的功能），并且由于子类也有这样的方法，就会无限调用下去直到程序崩溃，为此，我们可以使用关键字super来覆盖已有的方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决覆盖的问题，C++中需要写出整个父类的名称，而Java中super关键字直观的告诉我们，这个地方使用的是父类的方法，因此不会造成死循环。在子类中我们可以增加域，方法或者覆盖超类的方法，然而绝对不能删除继承的任何域和方法。<br>this作为隐式参数这个关键字有两个用途，一是可以被引用，二是调用该类的其他构造器，同样的super也作为一个隐式参数不光可以被引用，也可以调用父类的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">double</span> salary, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//super必须放在构造器的最前面</span></span><br><span class="line">        <span class="built_in">super</span>(name, salary, year, month, day);</span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果调用for-each循环的时候，在调用父类和子类同名不同功能的方法时，虚拟机会自己判断对象是父类还是子类再进行相应的调用。<br>一个对象变量可以指示多种实际类型的现象成为<strong>多态</strong>，在与运行时能够自动选择调用的方法的现象称为<strong>动态绑定</strong>。如果是private，static，final的方法被称为<strong>静态绑定</strong>。<br>在Java中，对象变量是多态的，一个Employee对象即可以引用一个Employee对象，也可以引用Employee子类的对象，反之则不可以，并且调用方法的时候遵循哪个类的对象才可以调用哪个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关于类的强制类型转换，只能自顶向下进行转换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Employee类的对象变量引用boss，可以运行</span></span><br><span class="line">        <span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">staff</span> <span class="operator">=</span> boss;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Manager类的对象变量引用worker，不能运行</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">errorBoss</span> <span class="operator">=</span> worker;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//可以用boss调用专属于Manager的方法，而staff不可以</span></span><br><span class="line">        <span class="comment">//即使他们引用的是同一个对象</span></span><br><span class="line">        boss.setBonus(<span class="number">5000</span>); <span class="comment">// OK</span></span><br><span class="line">        staff.setBonus(<span class="number">5000</span>); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不允许被扩展的类被称为final类，在定义类的时候添加final修饰符即可，同理，不允许被覆盖的方法被称为final方法。<br>如果两个相似的子类需要输出一串简介信息，但是内容相差比较大，对于父类来说不太容易定义这个看似关联实则区别比较大的方法，这里就可以用到<strong>抽象类</strong>这个概念：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在父类中创建抽象方法后，在子类中重载即可。</span></span><br><span class="line">    <span class="comment">// 类比于C++中的：virtual string getDescription() = 0;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在自下而上的继承中，位于上层的类更通用的同时也更抽象，因此抽象abstract这个关键字就很好的解决了这个问题.<br>对于java中的访问，有以下四种情况：  </p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">子类</th>
<th align="center">所有类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h4 id="II-所有类的父类-Object"><a href="#II-所有类的父类-Object" class="headerlink" title="II 所有类的父类 - Object"></a>II 所有类的父类 - Object</h4><p>在Java中，除了基本类型（数值，字符，布尔值）以外，所有的变量都是对象变量，包括我们常见的数组（包括对象数组和普通数组）都是扩展了Object类的对象。<br>Object类是所有类的父类，我们定义类的时候虽然没有写出”extends Object“，但实际上却有这个含义。<br>以下将介绍部分Object类提供的方法，关于处理线程的方法将在后续介绍：  </p>
<ul>
<li>equals：用于比较两个类是否相等，默认的比较方式是检查是否具有相同的引用，确认两个对象是否相等需要很多逻辑上的判断且子类需要先调用父类的equals。  </li>
<li>hashCode：返回对象的散列码，可以理解成对象的ID，默认的散列码为对象的存储地址。hashcode自定义散列码时要保证相同对象有相同散列码，也可以用静态方法Object.hash(需要比较的参数)来生成。  </li>
<li>toString：返回对象的字符串，默认是类的名字+地址，自定义这个方法是一种非常有用的调试工具，标准类库中有很多这样的方法重载  <h4 id="III-泛型数组列表-ArrayList-与包装器"><a href="#III-泛型数组列表-ArrayList-与包装器" class="headerlink" title="III 泛型数组列表(ArrayList)与包装器"></a>III 泛型数组列表(ArrayList)与包装器</h4>对于类似C++中的vector可变数组的操作，java中提供了ArrayList类，它是一个采用类型参数的泛型类，使用时需要用尖括号来定义对象的类型：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类比于C++的模板</span><br><span class="line">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>
ArrayList类和C++的vector极为相似，但是需要注意的是，java中没有运算符的重载，意味着不能通过[]来访问元素，并且访问和修改元素的操作需要get和set方法来实现。<br>除此之外，虽说在Java这个极度面向对象的设计语言中，基础数据类型不作为对象存在，不过我们可以用他们来制造属于他们的对象，也就是包装器，具体类型的包装器对应其英文拼写：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//包装器可以实现自动打包(装箱),等价于list.add(Integer.valueOf(3));</span><br><span class="line">list.add(3);</span><br><span class="line">//也可以实现自动拆箱，等价于list.get(i).intValue();</span><br><span class="line">int n = list.get(i);</span><br></pre></td></tr></table></figure>
除此之外，包装器还提供了许多实用的静态方法，如Integer类中的ParseInt(String)可以将字符串转换为整数并返回。  <h4 id="IV-可变参数的方法"><a href="#IV-可变参数的方法" class="headerlink" title="IV 可变参数的方法"></a>IV 可变参数的方法</h4>顾名思义，即参数不固定的例子，printf就是一个很好的例子:  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里的...是实际代码的一部分，表明可以接受任意数量的对象</span></span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object...args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上，printf接收到的两个参数分别为fmt和Object[]数组，也就是说，对于使用者而言，Object…参数类型和Object[]完全一样。  <h4 id="V-继承的设计技巧"><a href="#V-继承的设计技巧" class="headerlink" title="V 继承的设计技巧"></a>V 继承的设计技巧</h4></li>
<li>将公共操作和域放在父类中  </li>
<li>非特殊情况下，不要使用protected</li>
<li>使用继承实现”is-a”的关系，构建成一棵树</li>
<li>除非所有的继承方法都有意义，否则不要使用继承</li>
<li>在重载方法的时候，不要改变预期的行为</li>
<li>使用多态，而非一连串的分支</li>
<li>不要过多使用反射库</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础 | 2、类与对象</title>
    <url>/2022/03/23/JAVA_Basic/JAVA%E5%9F%BA%E7%A1%80-2-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="第二部分-类与对象"><a href="#第二部分-类与对象" class="headerlink" title="第二部分 类与对象"></a>第二部分 类与对象</h3><p>众所周知，“xxx是一门面向对象的编程语言”这句话折磨了许多初学面向对象的同学们（总之包括而我），因此，虽然这个说法非常不负责并且非常有问题，但是我需要直接了当的说：<strong>面向对象不就是结构体+函数吗</strong>（当然不是）  </p>
<span id="more"></span>
<h4 id="I-面向对象中java与C-的区别"><a href="#I-面向对象中java与C-的区别" class="headerlink" title="I 面向对象中java与C++的区别"></a>I 面向对象中java与C++的区别</h4><p>事实上，Java作为一个摒弃了指针的语言来讲，面向对象这部分与C++有着显著的不同，比如说在对象实例化的部分：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date birthday; // java:实例化一个Date对象，对象名称为birthday</span><br><span class="line">//然而在C++中的实际含义如下，尽管形式一样</span><br><span class="line">Date* birthday; // C++  </span><br></pre></td></tr></table></figure>
<p>并不只是面向对象这部分，Java中的变量并没有进行赋值，而是一个变量指向了一个数据，由此可见，与其说Java是摒弃了指针的语言，不如说是全程都在用（简化版的）指针的语言<del>（真香啊</del><br>在面向对象的程序中，应该尽量避免一个方法能够修改对象属性，甚至是直接访问对象属性，这都是不安全的，因此java类的设计通常有以下指定功能的方法：  </p>
<ul>
<li>构造器：最朴实无华的构造器，简单粗暴的new一个新对象，传统中的传统</li>
<li>静态工厂的构造器：不使用传统的构造器构造对象，而是使用这种特殊的方法（接口）构造一个新对象并且作为返回值可以赋值给对象变量  </li>
<li>更改器：看似是修改了对象的属性，其实是返回了一个属性不一样的新对象  </li>
<li>访问器：只访问对象而不修改对象的方法被称为访问器</li>
</ul>
<p>听起来似乎花里胡哨，但本质上他们都是一个类&#x2F;对象的方法罢了，只不过是人们根据他们的功能或特性起了一个（听起来很高端的）新名字，下面这个程序案例可以充分展示上述中三个新方法的使用：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> MyJava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里是静态工厂</span></span><br><span class="line">        <span class="comment">//使用静态工厂实例化一个表示现在日期的对象，对象名称为date</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过date对象，得到int型的月份和日期（这个月的第几天）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> date.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> date.getDayOfMonth();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//date的日期更新为该月的第一天，也就是减去today再+1，赋值给date，再通过DayOfWeek类与方法返回星期数，并用value得到值</span></span><br><span class="line">        date = date.minusDays(today - <span class="number">1</span>); <span class="comment">// 这里是更改器</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> date.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue(); <span class="comment">// 这里是访问器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出表头，即格式部分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;value; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出日历主体，只要还在当月就继续循环</span></span><br><span class="line">        <span class="keyword">while</span>(date.getMonthValue() == month)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出日期</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,date.getDayOfMonth());</span><br><span class="line">            <span class="comment">//判断是否为今天</span></span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfMonth() == today)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新date</span></span><br><span class="line">            date = date.plusDays(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Mon Tue Wed Thu Fri Sat Sun</span></span><br><span class="line"><span class="comment">      1   2   3   4   5   6 </span></span><br><span class="line"><span class="comment">  7   8   9  10  11  12  13 </span></span><br><span class="line"><span class="comment"> 14  15  16  17  18  19  20 </span></span><br><span class="line"><span class="comment"> 21  22  23* 24  25  26  27 </span></span><br><span class="line"><span class="comment"> 28  29  30  31 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用这些类，接口和方法，可以轻松处理日历的很麻烦的问题（尤其是不用考虑一大堆边界条件，因为大犇们已经提前造好轮子了），  </p>
<h4 id="II-用户自定义类"><a href="#II-用户自定义类" class="headerlink" title="II 用户自定义类"></a>II 用户自定义类</h4><p>与c++结构类似，其区别第一在于java的各种属性与方法有着很长的前缀，其二在于java在声明方法的时候定义方法。不过，前者只是将C++的访问权限展开罗列，后者将每个类定义在一个java文件中，所以综上所述java的自定义类和C++结构依然相似。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个最简单的java类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//field1</span></span><br><span class="line">    <span class="comment">//field2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//constructor1</span></span><br><span class="line">    <span class="comment">//constructor2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//method1</span></span><br><span class="line">    <span class="comment">//method2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止域值（对象的属性）出错或者随意修改，应该在针对一个属性拥有以下三个内容：</p>
<ul>
<li>一个私有的数据域  </li>
<li>一个公有的域访问器的方法  </li>
<li>一个公有的域更改器的方法</li>
</ul>
<p>这样有很多好处，一是内部实现不会影响其他代码，二是更改其可以执行错误检查<br>同时为了防止数据域的出错，在需要返回一个<strong>可变对象</strong>的时候需要进行克隆：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OutPut</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Date theDay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下是不安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> theDay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是安全的做法</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getDay</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) theday.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="III-静态域与静态方法"><a href="#III-静态域与静态方法" class="headerlink" title="III 静态域与静态方法"></a>III 静态域与静态方法</h4><p>静态前缀修饰符static即将变量的作用域设置为静态，这个修饰符可以作用于以下内容：  </p>
<ul>
<li>静态域：</li>
</ul>
<p>将成员属性设置为静态，即<strong>类中所有对象都公用一个的属性</strong>，在其他面向对象的语言中也会将其称为“类域”，对于静态域的使用有以下经典用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动设置雇员的id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态常量</li>
</ul>
<p>即在常量中用static修饰，最经典的例子就是在Math类中的静态常量PI。<br>静态常量因为不能被修改，所以设置成公有也是没有问题的。  </p>
<ul>
<li>静态方法</li>
</ul>
<p>静态方法是一种不能对对象实施操作的方法，也就是没有this参数的方法，例如，Math终端pow方法，在使用时不许呀哦任何Math对象。<br>虽然静态方法不能访问实例域，但是可以访问静态域，也可以通过类名待用这个方法。  </p>
<ul>
<li>静态工厂</li>
</ul>
<p>类似LocalDate和NumberFormat的类使用静态工厂方法来构建对象，以NumberFormat为例，不使用构造器有以下两点原因：<br>一方面构造器的名字必须与类名相同，而实际希望将得到两种不同的名字<br>另一方面使用构造器时无法改变所构造的对象类型，而Factory方法将返回一个DecimalFormat类的对象，也就是NumberFormat的子类。  </p>
<ul>
<li>main方法</li>
</ul>
<p>调用静态方法不需要对象，同理。main方法也是一个静态方法，main函数不需要对任何对象进行操作。<br>事实上，程序启动的时候没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。<br>注： 每一个类都可以有一个main方法，常用于对类进行单元测试</p>
<ul>
<li>声明时赋值与初始化块</li>
</ul>
<p>虽然java可以使用常规的构造器初始化数据域，与C++不同，java可以在类声明属性的时候就对其进行初始化，除此之华还有“初始化块”这个第三种机制，只要构造类的对象，这些块就会被执行，对于静态域进行初始化的初始化块可以在花括号前单独加一个static前缀<br>类中调用构造器的顺序为：<br>数据域初始化为默认值 -&gt; 按照声明中出现的次序执行初始化块 -&gt; 若构造器中有其他构造器，先执行内部构造器，再执行外部构造器</p>
<h4 id="IV-包"><a href="#IV-包" class="headerlink" title="IV 包"></a>IV 包</h4><p>包是java中管理类的容器，一个类可以使用<strong>所属包中的所有类</strong>，以及<strong>其他包中的公有类</strong>，我们可以有两种方法访问其他包中的类：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种方法 显然比较繁琐</span><br><span class="line">java.time.LocalDate todaty = java.time.LocalDate.now();</span><br><span class="line"></span><br><span class="line">第二种方法，*代表导入这个包内的所有类，当然也可以只导入特定的类</span><br><span class="line">import java.until.*;</span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">除此之外，import语句不仅可以导入类，还可以用来导入静态方法和静态域（不过这样会很大程度降低代码的清晰度）  </span><br><span class="line">同理，设计好的类也需要放在包中。可以用以下语句实现：  </span><br><span class="line">```java</span><br><span class="line">package nameOfpackage;</span><br></pre></td></tr></table></figure>

<p>如果在包的目录中没有对应的类，也可以进行编译，但是最终程序无法正常运行，因此需要先将所有类文件移到正确的位置上。<br>除此之外，类文件也可以存储在JAR文件中，JAR文件可以理解为Java归档的ZIP格式组织文件，JDK提供了许多JAR文件的类库，同时JAR文件也方便其他第三方库的使用。  </p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>编程语言学习</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础 | 1、首次登陆的简单指令</title>
    <url>/2022/03/23/Linux_Basic/Linux%E5%9F%BA%E7%A1%80-1-%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86%E7%9A%84%E7%AE%80%E5%8D%95%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>虽然但是，第一次面对控制台的操作系统，即没有知识储备，又害怕不小心弄错了什么，那就从最简单的一些系统指令入手8</p>
<span id="more"></span>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="I-指令格式"><a href="#I-指令格式" class="headerlink" title="I 指令格式"></a>I 指令格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user@name ~]$ command [options] parameter1 parameter2 …</span><br></pre></td></tr></table></figure>
<p>绝大多数指令遵循以上框架，其详细说明如下：  </p>
<ul>
<li>@前的user指的是用户名，@后的name指的是计算机的名称，~符号表明文件的home目录  </li>
<li>$符号指的是“提示字符”，表示可以开始输入指令，其中root的提示字符为#  </li>
<li>command指的是指令名称或可执行文件</li>
<li>options指的是选项设定，实际使用时不加[]而是大部分用-作为前缀  </li>
<li>parameter指的是指令的参数，以<strong>不计个数的空格</strong>区分  </li>
<li>指令输入完毕后，回车键表示执行指令，指令太长时使用反斜杠\来跳脱回车符号</li>
</ul>
<p>注：Linux指令严格区分大小写，空格和回车是很重要的字符。  </p>
<p>尝试以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al ~</span><br></pre></td></tr></table></figure>
<p>效果为列出home目录下的所有隐藏档与相关文件的属性<br>关于指令的严格区分大小写，以下案例可以充分展示：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date //显示日期和实现</span><br><span class="line">Date //找不到指令</span><br><span class="line">DATE //找不到指令</span><br></pre></td></tr></table></figure>
<p>综上所述，大小写在Linux中是有很大区别的。  </p>
<h4 id="II-语系"><a href="#II-语系" class="headerlink" title="II 语系"></a>II 语系</h4><p>由于Linux是支持多国语系的，如果系统默认设置下无法支持以中文编码输出数据，我们需要自行将支持语系改为英文，可以用到以下指令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale //显示目前支持的语系</span><br></pre></td></tr></table></figure>
<p>LANG 指语言语系的输出<br>LC_TIME 指时间方面的语系数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=en_US.utf8 //更改输出信息的语系</span><br><span class="line">export LC_ALL=en_US.utf8 //同步更新LC_ALL</span><br></pre></td></tr></table></figure>
<p>通过以上设置，就能够在本次登入中查看英文信息了  </p>
<h4 id="III-基础指令操作"><a href="#III-基础指令操作" class="headerlink" title="III 基础指令操作"></a>III 基础指令操作</h4><ul>
<li>显示日期的指令 date</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>不加任何参数的date指令可以输出当前时间，且格式为星期+月+日+时+分+秒+时区+年份<br>当然也可以输入带有参数的指令  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date +%Y/%m/%d //显示为 年/月/日</span><br><span class="line">date +%H:%M //显示为 时：分</span><br></pre></td></tr></table></figure>
<p>其中，第一行命令中的选项部分不一定以-开头，也可以由+开头  </p>
<ul>
<li><p>显示日历的指令 cal  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cal //直接输出本月的日历</span><br><span class="line">cal 2015 //输出2015年一整年的日历</span><br></pre></td></tr></table></figure>
<p>基本上cal这个命令可以接的语法为cal [month] [year]<br>当然如果输入了不存在的月份会出现对应的错误提示，对于Linux指令而言，指令反馈的错误是debug的一大关键信息  </p>
<h4 id="VI-重要的热键"><a href="#VI-重要的热键" class="headerlink" title="VI 重要的热键"></a>VI 重要的热键</h4></li>
<li><p>Tab 类似于在IDE中，在Linux命令行中Tab主要负责“补全”这一功能  </p>
<ol>
<li>在command部分中使用tab代表命令补齐，即输出所有满足已经输入部分文字为开头的指令  </li>
<li>在之后的部分使用tab代表文件&#x2F;参数&#x2F;选项补齐，具体依情况而定</li>
</ol>
</li>
<li><p>ctrl+c 终端目前程序，常用来跳出死循环  </p>
</li>
<li><p>ctrl+d 离开程序或输入结束，可以用来代替exit  </p>
</li>
<li><p>shift+pageup&#x2F;down 前后翻页</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题-2-第三周</title>
    <url>/2022/04/11/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第三周题解</p>
<span id="more"></span>
<h4 id="AcWing-1683-困牛放牧—原题链接"><a href="#AcWing-1683-困牛放牧—原题链接" class="headerlink" title="AcWing 1683. 困牛放牧—原题链接"></a>AcWing 1683. 困牛放牧—<a href="https://www.acwing.com/problem/content/1685/">原题链接</a></h4><p>题目标签：  </p>
<blockquote>
<p>思路：<br>分情况讨论即可<br>对于最小的情况，如果三者已经连续了，那便不需要调整，如果两两之间有唯一空位，填充空位即可，否则只需要第一次将端点移到空一位的地方，接着填充即可<br>对u有最大的情况，从不相连到相连的过程就是填充点和点之间的距离，输出两个线段最长的一段的距离也就是要填充的最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; abs(a - b) - 1 &lt;&lt; &quot;-&quot; &lt;&lt; abs(b - c) - 1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span> == <span class="number">1</span> || <span class="built_in">abs</span>(b - c) - <span class="number">1</span> == <span class="number">1</span>)  <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span> == <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(b - c) - <span class="number">1</span> == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="built_in">abs</span>(a - b) - <span class="number">1</span>, <span class="built_in">abs</span>(b - c) - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1470-水桶传递队列—原题链接"><a href="#AcWing-1470-水桶传递队列—原题链接" class="headerlink" title="AcWing 1470. 水桶传递队列—原题链接"></a>AcWing 1470. 水桶传递队列—<a href="https://www.acwing.com/problem/content/1472/">原题链接</a></h4><p>题目标签：BFS  </p>
<blockquote>
<p>思路：<br>知道了起点和终点求最短路，直接BFS即可，模板题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line">PII st, ed;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    dist[st.first][st.second] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = t.first + dx[i], b = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= <span class="number">10</span> &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= <span class="number">10</span> &amp;&amp; g[a][b] != <span class="string">&#x27;R&#x27;</span> &amp;&amp; dist[a][b] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[a][b] = dist[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(a == ed.first &amp;&amp; b == ed.second) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c = s[j];</span><br><span class="line">            g[i][j+<span class="number">1</span>] = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span>) st = &#123;i, j+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;B&#x27;</span>) ed = &#123;i, j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; dist[ed.first][ed.second]<span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1761-阻挡广告牌—原题链接"><a href="#AcWing-1761-阻挡广告牌—原题链接" class="headerlink" title="AcWing 1761. 阻挡广告牌—原题链接"></a>AcWing 1761. 阻挡广告牌—<a href="https://www.acwing.com/problem/content/1763/">原题链接</a></h4><p>题目标签：暴力 | 区间求交集 | 计算几何  </p>
<blockquote>
<p>思路：<br>因为两个广告牌互不相交，所以求分别相交的两个部分即可，平面中香蕉部分即右端点的最小值*左端点的最大值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(b, d) - <span class="built_in">max</span>(a, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">(<span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">2</span>] - a[<span class="number">0</span>]) * (a[<span class="number">3</span>] - a[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">get</span>(a[i][<span class="number">0</span>], a[i][<span class="number">2</span>], a[<span class="number">2</span>][<span class="number">0</span>], a[<span class="number">2</span>][<span class="number">2</span>]) * <span class="built_in">get</span>(a[i][<span class="number">1</span>], a[i][<span class="number">3</span>], a[<span class="number">2</span>][<span class="number">1</span>], a[<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">area</span>(a[<span class="number">0</span>]) + <span class="built_in">area</span>(a[<span class="number">1</span>]) - res &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1749-阻挡广告牌-II—原题链接"><a href="#AcWing-1749-阻挡广告牌-II—原题链接" class="headerlink" title="AcWing 1749. 阻挡广告牌 II—原题链接"></a>AcWing 1749. 阻挡广告牌 II—<a href="https://www.acwing.com/problem/content/1751/">原题链接</a></h4><p>题目标签：模拟 | 分类讨论（不推荐）  </p>
<blockquote>
<p>思路：<br>看样子是个分类讨论，但是一方面需要分不少类，另一方面数据并不大，因此直接上暴力模拟，需要注意的是边转换为方格时的边界问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, B = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    a += B, b += B, c += B, d += B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a; i&lt;c; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=b; j&lt;d; j++) st[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    a += B, b += B, c += B, d += B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a; i&lt;c; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=b; j&lt;d; j++) st[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    a = b = N, c = d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a = <span class="built_in">min</span>(a, i);</span><br><span class="line">                b = <span class="built_in">min</span>(b, j);</span><br><span class="line">                c = <span class="built_in">max</span>(c, i);</span><br><span class="line">                d = <span class="built_in">max</span>(d, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(<span class="number">0</span>, d - b + <span class="number">1</span>), height = <span class="built_in">max</span>(<span class="number">0</span>, c - a + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; len * height &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1737-传送—原题链接"><a href="#AcWing-1737-传送—原题链接" class="headerlink" title="AcWing 1737. 传送—原题链接"></a>AcWing 1737. 传送—<a href="https://www.acwing.com/problem/content/1739/">原题链接</a></h4><p>题目标签：分类讨论  </p>
<blockquote>
<p>思路：<br>也就三种情况，应该是某复杂最短路题目的阉割版</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="built_in">abs</span>(a - b);</span><br><span class="line">    <span class="type">int</span> d2 = <span class="built_in">abs</span>(a - x) + <span class="built_in">abs</span>(y - b);</span><br><span class="line">    <span class="type">int</span> d3 = <span class="built_in">abs</span>(a - y) + <span class="built_in">abs</span>(x - b);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(d1, <span class="built_in">min</span>(d2, d3)) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1725-组队井字游戏—原题链接"><a href="#AcWing-1725-组队井字游戏—原题链接" class="headerlink" title="AcWing 1725. 组队井字游戏—原题链接"></a>AcWing 1725. 组队井字游戏—<a href="https://www.acwing.com/problem/content/1727/">原题链接</a></h4><p>题目标签：模拟 | 暴力  </p>
<blockquote>
<p>思路：<br>因为只有3x3的棋盘，所以直接暴力模拟一次就可以了，这里可以巧妙的运用set的自动查重</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">set&lt;set&lt;<span class="type">char</span>&gt;&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(g[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(g[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(g[<span class="number">0</span>][<span class="number">0</span>]);s.<span class="built_in">insert</span>(g[<span class="number">1</span>][<span class="number">1</span>]); s.<span class="built_in">insert</span>(g[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(g[<span class="number">2</span>][<span class="number">0</span>]);s.<span class="built_in">insert</span>(g[<span class="number">1</span>][<span class="number">1</span>]); s.<span class="built_in">insert</span>(g[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) s1.<span class="built_in">insert</span>(s);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) s2.<span class="built_in">insert</span>(s);</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl &lt;&lt; s2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing2022春季每日一题 | 第二周</title>
    <url>/2022/03/26/AcWing_DailyProblem_Spring2022/AcWing2022%E6%98%A5%E5%AD%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-2-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<p>AcWing2022春季每日一题，第二周题解</p>
<span id="more"></span>
<h4 id="AcWing-1442-单词处理器—原题链接"><a href="#AcWing-1442-单词处理器—原题链接" class="headerlink" title="AcWing 1442. 单词处理器—原题链接"></a>AcWing 1442. 单词处理器—<a href="https://www.acwing.com/problem/content/1444/">原题链接</a></h4><p>题目标签：字符串 | 模拟  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，派大星看了都会（向派大星道歉）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(now + s.<span class="built_in">size</span>() &lt;= k) now += s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            now = s.<span class="built_in">size</span>();</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="AcWing-1671-三角形—原题链接"><a href="#AcWing-1671-三角形—原题链接" class="headerlink" title="AcWing 1671. 三角形—原题链接"></a>AcWing 1671. 三角形—<a href="https://www.acwing.com/problem/content/1673/">原题链接</a></h4><p>题目标签：暴力 | 枚举  </p>
<blockquote>
<p>思路：<br>恩枚举就完了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line">vector&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;q.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;q.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;q.<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j || j==k || i==k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[i].first == q[j].first &amp;&amp; q[j].second == q[k].second)</span><br><span class="line">                        res = <span class="built_in">max</span>(res, <span class="built_in">abs</span>(q[j].first - q[k].first) * <span class="built_in">abs</span>(q[j].second - q[i].second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1659-社交距离-I—原题链接"><a href="#AcWing-1659-社交距离-I—原题链接" class="headerlink" title="AcWing 1659. 社交距离 I—原题链接"></a>AcWing 1659. 社交距离 I—<a href="https://www.acwing.com/problem/content/1661/">原题链接</a></h4><p>题目标签：分类讨论 | 模拟 | （也可以）二分  </p>
<blockquote>
<p>思路：<br>两头牛能摆放的情况，除了原先一头牛也没有之外，只有两种情况：<br>1、两头牛在同一去年内<br>2、两头牛分别在不同区间<br>算出这两种情况下的取值，取最大值的那个方案即为所需要的方案（输出时要和原先区间的最小值做比对并取最小值）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>) p[++cnt] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) cout &lt;&lt; n<span class="number">-1</span> &lt;&lt; endl; <span class="comment">//如果原先的序列里一头牛都没有</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xmin = N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) xmin = <span class="built_in">min</span>(xmin, p[i+<span class="number">1</span>] - p[i]); <span class="comment">// 原先区间中距离的最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两头牛在同一区间的方案</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">max</span>((p[<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>, (n-p[cnt])/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++) y = <span class="built_in">max</span>(y, (p[i+<span class="number">1</span>]-p[i])/<span class="number">3</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两头牛在不同区间的方案</span></span><br><span class="line">        <span class="type">int</span> y1 = p[<span class="number">1</span>]<span class="number">-1</span>, y2 = n-p[cnt];</span><br><span class="line">        <span class="keyword">if</span>(y1 &lt; y2) <span class="built_in">swap</span>(y1, y2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = (p[i+<span class="number">1</span>]-p[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= y1) y2 = y1, y1 = d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; y2) y2 = d;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(xmin, <span class="built_in">max</span>(y, y2)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=cnt; i++) cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1714-混合牛奶—原题链接"><a href="#AcWing-1714-混合牛奶—原题链接" class="headerlink" title="AcWing 1714. 混合牛奶—原题链接"></a>AcWing 1714. 混合牛奶—<a href="https://www.acwing.com/problem/content/1716/">原题链接</a></h4><p>题目标签：模拟 | 找规律（做的时候没找到…）  </p>
<blockquote>
<p>思路：<br>恩模拟就完了，这里面有规律可以找不过只需要操作100次因此恩模拟也没问题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">acow</span></span><br><span class="line">&#123;</span><br><span class="line">    PII a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acow cow;</span><br><span class="line">    cin &gt;&gt; cow.a.first &gt;&gt; cow.a.second &gt;&gt; cow.b.first &gt;&gt; cow.b.second &gt;&gt; cow.c.first &gt;&gt; cow.c.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1 -&gt; 2</span></span><br><span class="line">            <span class="keyword">if</span>(cow.a.second + cow.b.second &lt;= cow.b.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second += cow.a.second;</span><br><span class="line">                cow.a.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second -= cow.b.first -  cow.b.second;</span><br><span class="line">                cow.b.second = cow.b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2 -&gt; 3</span></span><br><span class="line">            <span class="keyword">if</span>(cow.b.second + cow.c.second &lt;= cow.c.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second += cow.b.second;</span><br><span class="line">                cow.b.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.b.second -= cow.c.first - cow.c.second;</span><br><span class="line">                cow.c.second = cow.c.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//3 -&gt; 1</span></span><br><span class="line">            <span class="keyword">if</span>(cow.c.second + cow.a.second &lt;= cow.a.first)</span><br><span class="line">            &#123;</span><br><span class="line">                cow.a.second += cow.c.second;</span><br><span class="line">                cow.c.second = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cow.c.second -= cow.a.first - cow.a.second;</span><br><span class="line">                cow.a.second = cow.a.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cow.a.second &lt;&lt; endl &lt;&lt; cow.b.second &lt;&lt; endl &lt;&lt; cow.c.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="AcWing-1695-果壳游戏—原题链接"><a href="#AcWing-1695-果壳游戏—原题链接" class="headerlink" title="AcWing 1695. 果壳游戏—原题链接"></a>AcWing 1695. 果壳游戏—<a href="https://www.acwing.com/problem/content/1697/">原题链接</a></h4><p>题目标签：模拟  </p>
<blockquote>
<p>思路：<br>将三个杯子预定义好，按照题目的要求进行交换，点中的杯子就杯子内容+1，也就是说如果这个杯子里提前放了鹅卵石那他就能猜对，最后输出最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">swap</span>(p[a], p[b]);</span><br><span class="line">        ans[p[c]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(ans+<span class="number">1</span>, ans+<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing春季每日一题2022</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>Acwing</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-776-Div-3</title>
    <url>/2022/04/20/codeforces/Codeforces-Round-776-Div-3-A-D%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>一定会补上剩下的题的，恩，一定会</p>
<span id="more"></span>
<h4 id="CodeForces-1650A-Deletions-of-Two-Adjacent-Letters—原题链接"><a href="#CodeForces-1650A-Deletions-of-Two-Adjacent-Letters—原题链接" class="headerlink" title="CodeForces 1650A. Deletions of Two Adjacent Letters—原题链接"></a>CodeForces 1650A. Deletions of Two Adjacent Letters—<a href="https://codeforces.com/contest/1650/problem/A">原题链接</a></h4><p>题目标签：思维题  </p>
<blockquote>
<p>思路：<br>除去只有一个字母的特殊情况，字符串中对出现的目标字母左右字符个数进行统计，只要满足一个字母的左右都是偶数，也就是能两个两个消掉就成立，否则不成立</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] != c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = s.<span class="built_in">size</span>() - i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot;-&quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>((l &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (r &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650B-DIV-MOD—原题链接"><a href="#CodeForces-1650B-DIV-MOD—原题链接" class="headerlink" title="CodeForces 1650B. DIV + MOD—原题链接"></a>CodeForces 1650B. DIV + MOD—<a href="https://codeforces.com/contest/1650/problem/B">原题链接</a></h4><p>题目标签：数学  </p>
<blockquote>
<p>思路：<br>目标函数有两部分组成：<br>前半部分是单调递增的一次函数，后半部分是值域在[0, a-1]的周期函数，并且每个周期内递增<br>所以最大值有两个情况，要么是最右端，要么是周期函数中最靠右的峰值对应的点<br>注意定义域要在[l, r]之间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"><span class="type">int</span> l, r, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x / n) + (x % n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">f</span>(r);</span><br><span class="line">    <span class="type">int</span> t = r - r % n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">f</span>(t);</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= l) a = <span class="built_in">max</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650C-Weight-of-the-System-of-Nested-Segments—原题链接"><a href="#CodeForces-1650C-Weight-of-the-System-of-Nested-Segments—原题链接" class="headerlink" title="CodeForces 1650C. Weight of the System of Nested Segments—原题链接"></a>CodeForces 1650C. Weight of the System of Nested Segments—<a href="https://codeforces.com/contest/1650/problem/C">原题链接</a></h4><p>题目标签：贪心  </p>
<blockquote>
<p>思路：<br>反复排序求贪心即可，非常暴力的做法，总感觉会被hack…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TIMES;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id, dx, w, mark;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dx &lt; b.dx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    node nodes[m+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> maxx = <span class="number">-1e9</span>, minn = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        nodes[i] = &#123;i, a, b, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(nodes+<span class="number">1</span>, nodes+<span class="number">1</span>+m, cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[i].mark = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nodes+<span class="number">1</span>, nodes+<span class="number">1</span>+m, cmp2);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = n;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=m;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nodes[i].mark &gt; <span class="number">2</span> * n) i++;</span><br><span class="line">        <span class="keyword">while</span>(nodes[j].mark &gt; <span class="number">2</span> * n) j--;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;nodes[i].id, nodes[j].id&#125;);</span><br><span class="line"></span><br><span class="line">        res = res + nodes[i].w + nodes[j].w;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; t.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i=1; i&lt;=m; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; nodes[i].dx &lt;&lt; &quot; : &quot; &lt;&lt; nodes[i].w &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1650D-Twist-the-Permutation—原题链接"><a href="#CodeForces-1650D-Twist-the-Permutation—原题链接" class="headerlink" title="CodeForces 1650D. Twist the Permutation—原题链接"></a>CodeForces 1650D. Twist the Permutation—<a href="https://codeforces.com/contest/1650/problem/D">原题链接</a></h4><p>题目标签：暴力 | 模拟  </p>
<blockquote>
<p>思路：<br>按照题目要求，恩模拟就完了，难点在于边界判断啊……<br>不得不说，虽然没有什么技术含量在里面，但是不看题解啃出来还是蛮有成就感</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> TIMES, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> point = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] == i)</span><br><span class="line">            &#123;</span><br><span class="line">                point = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(point == i) ans[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> ans[i] = point;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = j - point + i;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= i+<span class="number">1</span>) t -= i;</span><br><span class="line">            b[t] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a = b;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; TIMES;</span><br><span class="line">    <span class="keyword">while</span>(TIMES -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>codeforces</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title>html与CSS实现带下拉菜单的导航栏</title>
    <url>/2022/05/30/Web%E7%BD%91%E9%A1%B5/html%E4%B8%8ECSS%E5%AE%9E%E7%8E%B0%E5%B8%A6%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AF%BC%E8%88%AA%E6%A0%8F/</url>
    <content><![CDATA[<p>使用html和CSS实现简单带下拉二级菜单的导航栏</p>
<span id="more"></span>
<h3 id="带下拉菜单导航栏的制作"><a href="#带下拉菜单导航栏的制作" class="headerlink" title="带下拉菜单导航栏的制作"></a>带下拉菜单导航栏的制作</h3><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>菜单栏布局：弹性盒子+列表+超链接</p>
<p>悬浮于窗口：绝对定位</p>
<p>下拉实现：元素y轴缩放</p>
<h4 id="文本部分"><a href="#文本部分" class="headerlink" title="文本部分"></a>文本部分</h4><p>使用两个div区分空间，分别为导航栏的背景和内容区域，菜单部分使用列表实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu_background&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu_area&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu_list&quot;</span>&gt;</span><span class="comment">&lt;!--菜单部分--&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而菜单内容的具体部分，我们使用li标签嵌套a标签实现跳转功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_text_a&quot;</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而下拉的二级菜单则是在这个li中再嵌套一个列表，我们这里使用有序列表和一级菜单进行区分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_text_a&quot;</span>&gt;</span>一级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu_dropdown_a&quot;</span>&gt;</span>二级标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="文本位置调整"><a href="#文本位置调整" class="headerlink" title="文本位置调整"></a>文本位置调整</h4><p>因为很多元素默认自带内外边距，种类多了会很麻烦，所以提前将所有元素的内外边距归零，有需要的时候再做调整</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先确定出整个导航栏的背景，使用绝对定位让他相对浏览器窗口固定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_background</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">position</span>: fixed; // 元素位置设置为绝对定位</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">10</span>; // 使导航栏悬浮在内容上方</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">3px</span> <span class="built_in">rgb</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用弹性布局将纵向显示的导航栏改为横向，设置列表元素大小填充父元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_area</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; // 填充父元素</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex; // 显示为弹性布局</span><br><span class="line">    <span class="attribute">list-style</span>: none; // 取消列表表头</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上边的方法设置二级菜单</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nemu_dropdown_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>; // 因为导航栏的高度是<span class="number">50px</span>，所以下拉菜单也这样设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为跳转功能是使用a标签实现的，所以对一二级菜单的a标签进行设置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//基础设置两个地方的<span class="selector-tag">a</span>标签相同，这里以一级菜单的<span class="selector-tag">a</span>标签为例</span><br><span class="line"><span class="selector-class">.menu_text_a</span></span><br><span class="line">&#123;</span><br><span class="line">    // 因为<span class="selector-tag">a</span>标签是行内元素，我们需要把他显示为块元素才能设置宽高</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: black; // 取消<span class="selector-tag">a</span>标签自带的颜色</span><br><span class="line">    <span class="attribute">text-decoration</span>: none; // 取消下划线</span><br><span class="line">    <span class="attribute">text-align</span>: center; // 水平居中</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>; // 设置行间距，使其垂直居中</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现下拉功能"><a href="#实现下拉功能" class="headerlink" title="实现下拉功能"></a>实现下拉功能</h4><p>使用缩放实现下拉和关闭，因此在下拉菜单部分写上下拉内容</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    // 核心代码 下拉实现的原理</span><br><span class="line">    // 我们将列表收缩为<span class="number">0</span> 在我们看来也就是消失了 需要时展开为<span class="number">1</span>即可</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>); // 在y轴上收缩为<span class="number">0</span></span><br><span class="line">    // 元素默认变化位置在元素中心</span><br><span class="line">    // 为了表现出下拉的动画，我们将位置设置为元素上方</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.6s</span>; // 所有动画触发时间为<span class="number">0.6s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发的效果是：鼠标悬停在一级菜单上，其内部的下拉菜单展开</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.menu_block</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.menu_dropdown_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>); // 列表缩放变为<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    *</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_background</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">3px</span> <span class="built_in">rgb</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_area</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_block</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_text_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transition</span>: all <span class="number">0.6s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_block</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_dropdown_a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">        <span class="attribute">text-align</span>: center;</span><br><span class="line">        <span class="attribute">background-color</span>: blue;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.the_block</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.the_dropdown_list</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;the_background&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;the_area&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">ul</span> class=&quot;the_list&quot;&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                &lt;<span class="selector-tag">ol</span> class=&quot;the_dropdown_list&quot;&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">li</span> class=&quot;the_dropdown_block&quot;&gt;</span><br><span class="line">                        &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_dropdown_a&quot;&gt;二级菜单&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">                    &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">                &lt;/<span class="selector-tag">ol</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">li</span> class=&quot;the_block&quot;&gt;</span><br><span class="line">                &lt;<span class="selector-tag">a</span> href=&quot;&quot; class=&quot;the_text_a&quot;&gt;一级标签&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总而言之并没有用什么高级的技术，适配性也不怎么样，不过用来 完成大学里面的网页大作业应该是没问题了，该帖子主要以学习为主，不建议直接复制源码在工程中使用</p>
]]></content>
      <categories>
        <category>Web网页</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>教程</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces-Round-783-Div-2</title>
    <url>/2022/04/20/codeforces/Codeforces-Round-783-Div-2-A-C%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>div2#783赛后补题，比赛只做出来了AB，C卡了好久QAQ</p>
<span id="more"></span>
<h4 id="CodeForces-1668A-Direction-Change—原题链接"><a href="#CodeForces-1668A-Direction-Change—原题链接" class="headerlink" title="CodeForces 1668A. Direction Change—原题链接"></a>CodeForces 1668A. Direction Change—<a href="https://codeforces.com/contest/1668/problem/A">原题链接</a></h4><p>题目标签：数学 | 贪心  </p>
<blockquote>
<p>思路：<br>首先考虑不可行的情况，在一行中只能左右走的情况如果长边大于3那自然是不可行了<br>紧接着，对于每张图，可以看成一个大正方形拼上了一个较小的矩形，正方形的边长是原矩形的宽<br>这么考虑的原因是，从正方形的左上走到右下的唯一最短路就是沿着对角线走“台阶”，即step&#x3D;(n-1)^2<br>再考虑右侧的小矩形，走“日”一定可以走到对应的点，当然需要对奇偶性进行特判</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a, b); <span class="comment">//保证a能够作为矩形的宽</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; b-a &gt;= <span class="number">2</span>) <span class="comment">//不成立情况的特判</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = b-a; <span class="comment">//小长方形的宽，判断其奇偶性</span></span><br><span class="line">        <span class="keyword">if</span>(d % <span class="number">2</span> == <span class="number">1</span>) cout &lt;&lt; (a<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>*(d<span class="number">-1</span>)+<span class="number">1</span> &lt;&lt; endl; <span class="comment">//奇数：最后一步是从左侧走进来的</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; (a<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>*d &lt;&lt; endl; <span class="comment">//偶数：最后一步是从上侧走进来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1668B-Social-Distance—原题链接"><a href="#CodeForces-1668B-Social-Distance—原题链接" class="headerlink" title="CodeForces 1668B. Social Distance—原题链接"></a>CodeForces 1668B. Social Distance—<a href="https://codeforces.com/contest/1668/problem/B">原题链接</a></h4><p>题目标签：贪心  </p>
<blockquote>
<p>思路：<br>若要满足所有人，消耗最多的一定是最麻烦的那个人，所以我们需要对数组排序然后对于最麻烦的人讨论<br>对于这个最麻烦的人，当他坐下后，已经不能再坐人的包括他的范围和他自己也就是a[max]*2+1<br>对于其他的人，坐在上一个人不能坐的边缘是是一定满足的，因为a[i]始终小于等于前者，因此只需要考虑他的一侧，也就是a[i]+1<br>最后一个人比较特殊，因为他的下一个就是最麻烦的人，因此他完全可以夹在两个人不能坐的边缘之间，也就是1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n, cmp); <span class="comment">//降序排序</span></span><br><span class="line">    LL num = a[<span class="number">0</span>] * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 处理消耗资源最多的那个人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++) num += a[i] + <span class="number">1</span>; <span class="comment">// 中间的人只需要判断一侧即可</span></span><br><span class="line">    num++; <span class="comment">// 处理消耗资源最少的那个人</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt;= num) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d&quot;, &amp;t);</span></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="CodeForces-1668C-Make-it-Increasing—原题链接"><a href="#CodeForces-1668C-Make-it-Increasing—原题链接" class="headerlink" title="CodeForces 1668C. Make it Increasing—原题链接"></a>CodeForces 1668C. Make it Increasing—<a href="https://codeforces.com/contest/1668/problem/C">原题链接</a></h4><p>题目标签：模拟 | 贪心(?)  </p>
<blockquote>
<p>思路：<br>硬核模拟，我是没看出来哪里需要贪心，一开始贪心的思路也错了，一道卡了一个半小时+的c题QAQ<br>因为需要满足单调性的同时减少操作次数，因此保证其中一个数为0，至于哪一位为0就遍历一次<br>遍历到一位为0的时候，模拟一边更新的过程，因为模拟时每个元素值只会被访问一次，因此时间复杂度为O(n^2)<br><strong>值得注意的是</strong>，没有过的很重要的原因是long long的初始值开小了，学到了应该开1e18<br>但是改了这一点使用新构建数组的模拟还是没有过，迷惑+1，于是附上官方做法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1e18</span>; <span class="comment">// long long 的最大初始值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL num = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对于每次循环，需要保证pre刚刚满足由a[j]的倍数并且超过之前的per</span></span><br><span class="line">            <span class="comment">// 因此原先的per对a[j]取模，这个时候再加上一个a[j]就刚刚好超过per了</span></span><br><span class="line">            <span class="comment">// 于是per需要更新的大小就是单位量a[j]和相差量的差</span></span><br><span class="line">            pre += a[j] - pre%a[j];</span><br><span class="line">            num += pre / a[j]; <span class="comment">// 计算达到这个结果需要多少单位个a[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            pre += a[j] - pre%a[j]; <span class="comment">// 反方向来一遍，思路一样</span></span><br><span class="line">            num += pre / a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">min</span>(res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法题解</tag>
        <tag>codeforces</tag>
        <tag>赛后补题</tag>
      </tags>
  </entry>
</search>
